<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Loretta</name>
    </assembly>
    <members>
        <member name="T:Loretta.Lexing.LuaLexerBuilder">
            <summary>
            The lexer builder for loretta's lexer.
            </summary>
        </member>
        <member name="M:Loretta.Lexing.LuaLexerBuilder.#ctor(Loretta.LuaOptions)">
            <summary>
            Initializes this lexer builder with the provided options.
            </summary>
            <param name="luaOptions">The options to be used by this builder and the lexer.</param>
        </member>
        <member name="M:Loretta.Lexing.LuaLexerBuilder.CreateLexer(System.String,System.IProgress{GParse.Diagnostic})">
            <summary>
            Creates a lexer from the provided code string and diagnostic reporter.
            </summary>
            <param name="code">The code to lex.</param>
            <param name="diagnosticReporter">The diagnostic reporter.</param>
            <returns>The lexer.</returns>
        </member>
        <member name="T:Loretta.Lexing.LuaTokenType">
            <summary>
            The type of the lua token.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.EOF">
            <summary>
            End of file.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.Comment">
            <summary>
            A single line comment (--...).
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.LongComment">
            <summary>
            A long comment (--[[...]]).
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.Whitespace">
            <summary>
            Any whitespace.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.Shebang">
            <summary>
            A shebang (#!...)
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.VarArg">
            <summary>
            A vararg (...).
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.String">
            <summary>
            A quoted string.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.LongString">
            <summary>
            A long/literal string literal.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.Number">
            <summary>
            A number literal.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.Boolean">
            <summary>
            A boolean literal.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.Nil">
            <summary>
            A nil literal.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.LParen">
            <summary>
            A left parenthesis '('.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.RParen">
            <summary>
            A right parenthesis ')'.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.LBracket">
            <summary>
            A left bracket '['.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.RBracket">
            <summary>
            A right bracket ']'.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.LCurly">
            <summary>
            A left curly bracket '{'.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.RCurly">
            <summary>
            A right curly bracket '}'.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.Semicolon">
            <summary>
            A semicolon ';'.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.Colon">
            <summary>
            A colon ':'.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.Dot">
            <summary>
            A dot '.'.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.Comma">
            <summary>
            A comma ','.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.Keyword">
            <summary>
            A keyword.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.Identifier">
            <summary>
            An identifier.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.Operator">
            <summary>
            An operator.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.LuaTokenType.GotoLabelDelimiter">
            <summary>
            A goto label delimiter '::'.
            </summary>
        </member>
        <member name="T:Loretta.Lexing.LuaTokenTypeExtensions">
            <summary>
            Extension methods for <see cref="T:Loretta.Lexing.LuaTokenType" />.
            </summary>
        </member>
        <member name="M:Loretta.Lexing.LuaTokenTypeExtensions.CanUseRawInError(Loretta.Lexing.LuaTokenType)">
            <summary>
            Checks whether a tokens <see cref="F:GParse.Lexing.Token`1.Raw" /> value can be used in an
            string message.
            </summary>
            <param name="tokenType">The token type.</param>
            <returns>Whether the raw value of the token can be used in a string.</returns>
        </member>
        <member name="T:Loretta.Lexing.Modules.DotLexerModule">
            <summary>
            Handles the parsing of ., .. and ... in the lexer.
            </summary>
        </member>
        <member name="P:Loretta.Lexing.Modules.DotLexerModule.Name">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Lexing.Modules.DotLexerModule.Prefix">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Lexing.Modules.DotLexerModule.CanConsumeNext(GParse.IO.IReadOnlyCodeReader)">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Lexing.Modules.DotLexerModule.ConsumeNext(GParse.IO.ICodeReader,System.IProgress{GParse.Diagnostic})">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Lexing.Modules.IdentifierLexerModule">
            <summary>
            Parses identifiers in the lexer.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.Modules.IdentifierLexerModule.Keywords">
            <summary>
            The identifier keywords registered with the module.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.Modules.IdentifierLexerModule.Operators">
            <summary>
            The identifier operators registered with the module.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.Modules.IdentifierLexerModule.Literals">
            <summary>
            The identifier literals registered with the module.
            </summary>
        </member>
        <member name="P:Loretta.Lexing.Modules.IdentifierLexerModule.Name">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Lexing.Modules.IdentifierLexerModule.Prefix">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Lexing.Modules.IdentifierLexerModule.LuaOptions">
            <summary>
            The <see cref="T:Loretta.LuaOptions" /> being used by this module.
            </summary>
        </member>
        <member name="M:Loretta.Lexing.Modules.IdentifierLexerModule.#ctor(Loretta.LuaOptions)">
            <summary>
            Initializes this module with the provided options.
            </summary>
            <param name="luaOptions">The options to be used by this module.</param>
        </member>
        <member name="M:Loretta.Lexing.Modules.IdentifierLexerModule.#ctor(Loretta.LuaOptions,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes this module with the provided options and keywords.
            </summary>
            <param name="luaOptions"><inheritdoc cref="M:Loretta.Lexing.Modules.IdentifierLexerModule.#ctor(Loretta.LuaOptions)" /></param>
            <param name="keywords">The keywords to be recognized by this module.</param>
        </member>
        <member name="M:Loretta.Lexing.Modules.IdentifierLexerModule.#ctor(Loretta.LuaOptions,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes this module with the provided options, keywords and operators.
            </summary>
            <param name="luaOptions">
            <inheritdoc cref="M:Loretta.Lexing.Modules.IdentifierLexerModule.#ctor(Loretta.LuaOptions,System.Collections.Generic.IEnumerable{System.String})" />
            </param>
            <param name="keywords">
            <inheritdoc cref="M:Loretta.Lexing.Modules.IdentifierLexerModule.#ctor(Loretta.LuaOptions,System.Collections.Generic.IEnumerable{System.String})" />
            </param>
            <param name="operators">The operators to be recognized by this module.</param>
        </member>
        <member name="M:Loretta.Lexing.Modules.IdentifierLexerModule.AddKeyword(System.String)">
            <summary>
            Adds an identifier that should be recognized as a keyword by this module.
            </summary>
            <param name="keyword">The identifier to be recognized as a keyword.</param>
        </member>
        <member name="M:Loretta.Lexing.Modules.IdentifierLexerModule.AddKeywords(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Adds identifiers that should be recognized as keywords by this module.
            </summary>
            <param name="keywords">The identifiers to be rocognized as keywords.</param>
        </member>
        <member name="M:Loretta.Lexing.Modules.IdentifierLexerModule.AddOperator(System.String)">
            <summary>
            Adds an identifier that should be recognized as an operator by this module.
            </summary>
            <param name="operator">The identifier that should be recognized as an operator.</param>
        </member>
        <member name="M:Loretta.Lexing.Modules.IdentifierLexerModule.AddOperators(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Adds identifiers that should be recognized as operators by this module.
            </summary>
            <param name="operators">The identifiers that should be recognized as operators.</param>
        </member>
        <member name="M:Loretta.Lexing.Modules.IdentifierLexerModule.AddLiteral(System.String,Loretta.Lexing.LuaTokenType,System.Object)">
            <summary>
            Adds an identifier that should be recognized as a literal by this module.
            </summary>
            <param name="literal">The identifier that should be recognized as a literal.</param>
            <param name="tokenType">The type of the literal token.</param>
            <param name="value">The value of the literal token.</param>
        </member>
        <member name="M:Loretta.Lexing.Modules.IdentifierLexerModule.CanConsumeNext(GParse.IO.IReadOnlyCodeReader)">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Lexing.Modules.IdentifierLexerModule.ConsumeNext(GParse.IO.ICodeReader,System.IProgress{GParse.Diagnostic})">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Lexing.Modules.LongCommentLexerModule">
            <summary>
            The long comment lexer module.
            </summary>
        </member>
        <member name="P:Loretta.Lexing.Modules.LongCommentLexerModule.Name">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Lexing.Modules.LongCommentLexerModule.Prefix">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Lexing.Modules.LongCommentLexerModule.CanConsumeNext(GParse.IO.IReadOnlyCodeReader)">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Lexing.Modules.LongCommentLexerModule.ConsumeNext(GParse.IO.ICodeReader,System.IProgress{GParse.Diagnostic})">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Lexing.Modules.LongStringLexerModule">
            <summary>
            The long strings lexer module.
            </summary>
        </member>
        <member name="P:Loretta.Lexing.Modules.LongStringLexerModule.Name">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Lexing.Modules.LongStringLexerModule.Prefix">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Lexing.Modules.LongStringLexerModule.CanConsumeNext(GParse.IO.IReadOnlyCodeReader)">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Lexing.Modules.LongStringLexerModule.ConsumeNext(GParse.IO.ICodeReader,System.IProgress{GParse.Diagnostic})">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Lexing.Modules.NumberLexerModule">
            <summary>
            Parses numbers in the lexer.
            </summary>
        </member>
        <member name="P:Loretta.Lexing.Modules.NumberLexerModule.Name">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Lexing.Modules.NumberLexerModule.Prefix">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Lexing.Modules.NumberLexerModule.LuaOptions">
            <summary>
            The options used by this module.
            </summary>
        </member>
        <member name="M:Loretta.Lexing.Modules.NumberLexerModule.#ctor(Loretta.LuaOptions)">
            <summary>
            Initializes this module with the provided options.
            </summary>
            <param name="luaOptions">The options to be used by this module.</param>
        </member>
        <member name="M:Loretta.Lexing.Modules.NumberLexerModule.IsUnderline(System.Char)">
            <summary>
            Checks whether the provided character is an underline and the options used by this
            module allows accepting underlines in numbers.
            </summary>
            <param name="ch">The character to check.</param>
            <returns>
            Whether the provided character is an underline and the options used by this module
            allows accepting underlines in numbers.
            </returns>
        </member>
        <member name="M:Loretta.Lexing.Modules.NumberLexerModule.IsHexadecimalChar(System.Char)">
            <summary>
            Checks whether the provided character is a hexadecimal character or an underline if the
            options used by this module allows accepting underlines in numbers.
            </summary>
            <param name="ch">The character to check.</param>
            <returns>
            Whether the provided character is a hexadecimal character or an underline if the options
            used by this module allows accepting underlines in numbers.
            </returns>
        </member>
        <member name="M:Loretta.Lexing.Modules.NumberLexerModule.IsDecimalChar(System.Char)">
            <summary>
            Checks whether the provided character is a decimal character or an underline if the
            options used by this module allows accepting underlines in numbers.
            </summary>
            <param name="ch">The character to check.</param>
            <returns>
            Whether the provided character is a decimal character or an underline if the options
            used by this module allows accepting underlines in numbers.
            </returns>
        </member>
        <member name="M:Loretta.Lexing.Modules.NumberLexerModule.IsOctalChar(System.Char)">
            <summary>
            Checks whether the provided character is an octal character or an underline if the
            options used by this module allows accepting underlines in numbers.
            </summary>
            <param name="ch">The character to check.</param>
            <returns>
            Whether the provided character is an octal character or an underline if the options used
            by this module allows accepting underlines in numbers.
            </returns>
        </member>
        <member name="M:Loretta.Lexing.Modules.NumberLexerModule.IsBinaryChar(System.Char)">
            <summary>
            Checks whether the provided character is a binary character or an underline if the
            options used by this module allows accepting underlines in numbers.
            </summary>
            <param name="ch">The character to check.</param>
            <returns>
            Whether the provided character is a binary character or an underline if the options used
            by this module allows accepting underlines in numbers.
            </returns>
        </member>
        <member name="M:Loretta.Lexing.Modules.NumberLexerModule.CanConsumeNext(GParse.IO.IReadOnlyCodeReader)">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Lexing.Modules.NumberLexerModule.ConsumeNext(GParse.IO.ICodeReader,System.IProgress{GParse.Diagnostic})">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Lexing.Modules.ShortStringLexerModule">
            <summary>
            Parses short strings in the lexer.
            </summary>
        </member>
        <member name="F:Loretta.Lexing.Modules.ShortStringLexerModule.escapes">
            <summary>
            The lookup table of single-char escapes.
            </summary>
        </member>
        <member name="P:Loretta.Lexing.Modules.ShortStringLexerModule.Name">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Lexing.Modules.ShortStringLexerModule.Prefix">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Lexing.Modules.ShortStringLexerModule.LuaOptions">
            <summary>
            The lua options used by this module.
            </summary>
        </member>
        <member name="M:Loretta.Lexing.Modules.ShortStringLexerModule.#ctor(Loretta.LuaOptions)">
            <summary>
            Initializes this module with the provided options.
            </summary>
            <param name="luaOptions">The options to be used by this module.</param>
        </member>
        <member name="M:Loretta.Lexing.Modules.ShortStringLexerModule.CanConsumeNext(GParse.IO.IReadOnlyCodeReader)">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Lexing.Modules.ShortStringLexerModule.ParseDecimalEscape(GParse.IO.ICodeReader,System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Parses a decimal number after the decimal escape prefix.
            </summary>
            <param name="reader">The reader to use.</param>
            <param name="rawBuffer">The builder for the raw string.</param>
            <param name="parsedBuffer">The builder for the parser string.</param>
        </member>
        <member name="M:Loretta.Lexing.Modules.ShortStringLexerModule.ParseHexadecimalEscape(GParse.IO.ICodeReader,System.Text.StringBuilder,System.Text.StringBuilder)">
            <summary>
            Parses a hexadecimal number after the hexadecimal escape prefix.
            </summary>
            <param name="reader">The reader to use.</param>
            <param name="rawBuffer">The builder for the raw string.</param>
            <param name="parsedBuffer">The builder for the parser string.</param>
        </member>
        <member name="M:Loretta.Lexing.Modules.ShortStringLexerModule.ConsumeNext(GParse.IO.ICodeReader,System.IProgress{GParse.Diagnostic})">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Lexing.TokenFactory">
            <summary>
            The utility class for generating tokens.
            </summary>
        </member>
        <member name="M:Loretta.Lexing.TokenFactory.ChangeTokenType(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Lexing.LuaTokenType)">
            <summary>
            Clones a token with a new type.
            </summary>
            <param name="token">The token's type to be changed.</param>
            <param name="type">The type to assign to the cloned token.</param>
            <returns>The token with the changed type.</returns>
        </member>
        <member name="M:Loretta.Lexing.TokenFactory.Token(System.String,Loretta.Lexing.LuaTokenType,System.String,System.Object,System.Nullable{GParse.SourceRange},System.Boolean)">
            <summary>
            Creates a new token with the provided data.
            </summary>
            <param name="id">The token's ID.</param>
            <param name="type">The token's type.</param>
            <param name="raw">The token's raw value. If null uses the <paramref name="id" />.</param>
            <param name="value">The token's value. Defaults to null.</param>
            <param name="range">
            The location range of the token. If null uses <see cref="F:GParse.SourceRange.Zero" />.
            </param>
            <returns>The newly created token.</returns>
        </member>
        <member name="M:Loretta.Lexing.TokenFactory.Identifier(System.String,System.Nullable{GParse.SourceRange})">
            <summary>
            Creates an identifier token.
            </summary>
            <param name="identifier">The identifier.</param>
            <param name="range">
            <inheritdoc cref="M:Loretta.Lexing.TokenFactory.Token(System.String,Loretta.Lexing.LuaTokenType,System.String,System.Object,System.Nullable{GParse.SourceRange},System.Boolean)" />
            </param>
            <returns>The identifier token.</returns>
        </member>
        <member name="M:Loretta.Lexing.TokenFactory.Boolean(System.Boolean,System.Nullable{GParse.SourceRange})">
            <summary>
            Creates a boolean literal token.
            </summary>
            <param name="value">The token's value.</param>
            <param name="range">
            <inheritdoc cref="M:Loretta.Lexing.TokenFactory.Token(System.String,Loretta.Lexing.LuaTokenType,System.String,System.Object,System.Nullable{GParse.SourceRange},System.Boolean)" />
            </param>
            <returns>The boolean literal token.</returns>
        </member>
        <member name="M:Loretta.Lexing.TokenFactory.Number(System.Double,System.String,System.Nullable{GParse.SourceRange})">
            <summary>
            Creates a number literal token.
            </summary>
            <param name="value">The token's value.</param>
            <param name="rawValue">
            The number's raw (string) form. If null calls <see
            cref="M:System.Double.ToString(System.IFormatProvider)" /> on the <paramref name="value" /> with <see
            cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </param>
            <param name="range">
            <inheritdoc cref="M:Loretta.Lexing.TokenFactory.Token(System.String,Loretta.Lexing.LuaTokenType,System.String,System.Object,System.Nullable{GParse.SourceRange},System.Boolean)" />
            </param>
            <returns>The number literal token.</returns>
        </member>
        <member name="M:Loretta.Lexing.TokenFactory.ShortString(System.String,System.String,System.Nullable{GParse.SourceRange})">
            <summary>
            Creates a short string token.
            </summary>
            <param name="value">The string's value.</param>
            <param name="rawValue">The string's raw (string) form.</param>
            <param name="range">
            <inheritdoc cref="M:Loretta.Lexing.TokenFactory.Token(System.String,Loretta.Lexing.LuaTokenType,System.String,System.Object,System.Nullable{GParse.SourceRange},System.Boolean)" />
            </param>
            <returns>The string literal token.</returns>
        </member>
        <member name="M:Loretta.Lexing.TokenFactory.LongString(System.String,System.String,System.Nullable{GParse.SourceRange})">
            <summary>
            Creates a long string literal token.
            </summary>
            <param name="value">The string's value.</param>
            <param name="rawValue">The string's raw (string) value.</param>
            <param name="range">
            <inheritdoc cref="M:Loretta.Lexing.TokenFactory.Token(System.String,Loretta.Lexing.LuaTokenType,System.String,System.Object,System.Nullable{GParse.SourceRange},System.Boolean)" />
            </param>
            <returns>The long string literal token.</returns>
        </member>
        <member name="M:Loretta.Lexing.TokenFactory.LongString(System.String,System.String,System.Nullable{GParse.SourceLocation})">
            <summary>
            Creates a long string literal token.
            </summary>
            <param name="value">The string's value.</param>
            <param name="rawValue">The string's raw (string) value.</param>
            <param name="start">The string's starting location.</param>
            <returns>The long string literal token.</returns>
        </member>
        <member name="M:Loretta.Lexing.TokenFactory.Comment(System.String,System.String,System.Nullable{GParse.SourceLocation})">
            <summary>
            Creates a single-line comment.
            </summary>
            <param name="value">The comment's contents.</param>
            <param name="rawValue">The comment's raw form.</param>
            <param name="start">The comment's start location.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Lexing.TokenFactory.LongComment(System.String,System.String,System.Nullable{GParse.SourceLocation})">
            <summary>
            Creates a new <see cref="F:Loretta.Lexing.LuaTokenType.LongComment"/> comment.
            </summary>
            <param name="value">The comment's contents.</param>
            <param name="rawValue">The comment's raw form.</param>
            <param name="start">The starting location of the token.</param>
            <returns></returns>
        </member>
        <member name="T:Loretta.LuaDiagnostics">
            <summary>
            The class containing the factory methods for the diagnostics emmitted by the lua parser
            along with a method to highlight a range in the source code.
            </summary>
        </member>
        <member name="M:Loretta.LuaDiagnostics.HighlightRange(System.String,GParse.SourceRange)">
            <summary>
            Highlights a range retrieving the line(s) referred to by the range and inserting ^'s
            under the code section that the range refers to.
            </summary>
            <param name="expression">The expression containing the range to be highlighted.</param>
            <param name="range">The range to highlight.</param>
            <returns></returns>
        </member>
        <member name="T:Loretta.LuaDiagnostics.SyntaxError">
            <summary>
            The class containing all syntax-error diagnostic factory methods.
            </summary>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpected(GParse.SourceRange,System.Object)">
            <summary>
            Creates an <see cref="F:GParse.DiagnosticSeverity.Error" /> diagnostic with ID LUA0001 and
            description in the format "{expected} expected.".
            </summary>
            <param name="range">The range the diagnostic refers to.</param>
            <param name="expected">What was expected.</param>
            <returns>The created diagnostic.</returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpected(GParse.SourceLocation,System.Object)">
            <summary>
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpected(GParse.SourceRange,System.Object)" />
            </summary>
            <param name="location">The location the diagnostic refers to.</param>
            <param name="expected"><inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpected(GParse.SourceRange,System.Object)" /></param>
            <returns><inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpected(GParse.SourceRange,System.Object)" /></returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpected(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},System.Object)">
            <summary>
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpected(GParse.SourceRange,System.Object)" />
            </summary>
            <param name="token">The token the diagnostic refers to.</param>
            <param name="expected"><inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpected(GParse.SourceRange,System.Object)" /></param>
            <returns><inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpected(GParse.SourceRange,System.Object)" /></returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedFor(GParse.SourceRange,System.Object,System.String)">
            <summary>
            Creates an <see cref="F:GParse.DiagnosticSeverity.Error" /> diagnostic with ID LUA0002 and
            description in the format "{expected} expected for {for}.".
            </summary>
            <param name="range">The range the diagnostic refers to.</param>
            <param name="expected">What was expected.</param>
            <param name="for">What needed the expected object.</param>
            <returns>The created diagnostic.</returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedFor(GParse.SourceLocation,System.Object,System.String)">
            <summary>
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedFor(GParse.SourceRange,System.Object,System.String)" />
            </summary>
            <param name="location">The location the diagnostic refers to.</param>
            <param name="expected">
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedFor(GParse.SourceRange,System.Object,System.String)" />
            </param>
            <param name="for">
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedFor(GParse.SourceRange,System.Object,System.String)" />
            </param>
            <returns><inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedFor(GParse.SourceRange,System.Object,System.String)" /></returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedFor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},System.Object,System.String)">
            <summary>
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedFor(GParse.SourceRange,System.Object,System.String)" />
            </summary>
            <param name="token">The token the diagnostic refers to.</param>
            <param name="expected">
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedFor(GParse.SourceRange,System.Object,System.String)" />
            </param>
            <param name="for">
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedFor(GParse.SourceRange,System.Object,System.String)" />
            </param>
            <returns><inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedFor(GParse.SourceRange,System.Object,System.String)" /></returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedAfter(GParse.SourceRange,System.Object,System.String)">
            <summary>
            Creates an <see cref="F:GParse.DiagnosticSeverity.Error" /> diagnostic with the ID LUA0002
            and description in the format "{expected} expected after {after}.".
            </summary>
            <param name="range">The range the diagnostic refers to.</param>
            <param name="expected">What was expected.</param>
            <param name="after">What was before what was expected.</param>
            <returns>The created diagnostic.</returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedAfter(GParse.SourceLocation,System.Object,System.String)">
            <summary>
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedAfter(GParse.SourceRange,System.Object,System.String)" />
            </summary>
            <param name="location">The location the diagnostic refers to.</param>
            <param name="expected">
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedAfter(GParse.SourceRange,System.Object,System.String)" />
            </param>
            <param name="after">
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedAfter(GParse.SourceRange,System.Object,System.String)" />
            </param>
            <returns><inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedAfter(GParse.SourceRange,System.Object,System.String)" /></returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedAfter(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},System.Object,System.String)">
            <summary>
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedAfter(GParse.SourceRange,System.Object,System.String)" />
            </summary>
            <param name="token">The token the diagnostic refers to.</param>
            <param name="expected">
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedAfter(GParse.SourceRange,System.Object,System.String)" />
            </param>
            <param name="after">
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedAfter(GParse.SourceRange,System.Object,System.String)" />
            </param>
            <returns><inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.ThingExpectedAfter(GParse.SourceRange,System.Object,System.String)" /></returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.InvalidEscapeInString(GParse.SourceRange)">
            <summary>
            Creates an <see cref="F:GParse.DiagnosticSeverity.Error" /> diagnostic with the ID LUA0003
            and description in the format "Unknown escape sequence.".
            </summary>
            <param name="range">The range the diagnostic refers to.</param>
            <returns>The created diagnostic.</returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.InvalidNumber(GParse.SourceRange,System.String)">
            <summary>
            Creates an <see cref="F:GParse.DiagnosticSeverity.Error" /> diagnostic with the ID LUA0004
            and description in the format "Invalid number '{raw}'.".
            </summary>
            <param name="range">The range the diagnostic refers to.</param>
            <param name="raw">The raw form of the number the diagnostic refers to.</param>
            <returns>The created diagnostic.</returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.InvalidNumber(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.InvalidNumber(GParse.SourceRange,System.String)" />
            </summary>
            <param name="token">The token the diagnostic refers to.</param>
            <returns><inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.InvalidNumber(GParse.SourceRange,System.String)" /></returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.NumberTooLarge(GParse.SourceRange,System.String)">
            <summary>
            Creates an <see cref="F:GParse.DiagnosticSeverity.Error" /> diagnostic with the ID LUA0005
            and description in the format "Number '{raw}' is too large.".
            </summary>
            <param name="range">The range the diagnostic refers to.</param>
            <param name="raw">The raw form of the number the diagnostic refers to.</param>
            <returns>The created diagnostic.</returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.NumberTooLarge(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            <inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.NumberTooLarge(GParse.SourceRange,System.String)" />
            </summary>
            <param name="token">The token the diagnostic refers to.</param>
            <returns><inheritdoc cref="M:Loretta.LuaDiagnostics.SyntaxError.NumberTooLarge(GParse.SourceRange,System.String)" /></returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.UnfinishedString(GParse.SourceRange)">
            <summary>
            Creates an <see cref="F:GParse.DiagnosticSeverity.Error" /> diagnostic with the ID LUA0006
            and description in the format "Unfinished string.".
            </summary>
            <param name="range">The range the diagnostic refers to.</param>
            <returns>The created diagnostic.</returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.UnfinishedLongComment(GParse.SourceRange)">
            <summary>
            Creates an <see cref="F:GParse.DiagnosticSeverity.Error"/> diagnostic with the ID LUA0007
            and description in the format "Unfinished long comment.".
            </summary>
            <param name="range">The range the diagnostic refers to.</param>
            <returns>The created diagnostic.</returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.LongCommentWithIncompatibleDelimiters(GParse.SourceRange)">
            <summary>
            Creates an <see cref="F:GParse.DiagnosticSeverity.Error"/> diagnostic with the ID LUA0008
            and description in the format "Long comment has an end with a different amount
            of equal signs than the start.".
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.UnfinishedLongString(GParse.SourceRange)">
            <summary>
            Creates an <see cref="F:GParse.DiagnosticSeverity.Error"/> diagnostic with the ID LUA0009
            and description in the format "Unfinished long string.".
            </summary>
            <param name="range">The range this diagnostic refers to.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.LuaDiagnostics.SyntaxError.LongStringWithIncompatibleDelimiters(GParse.SourceRange)">
            <summary>
            Creates an <see cref="F:GParse.DiagnosticSeverity.Error"/> diagnostic with the ID LUA0010
            and description in the format "Long string has an end with a different amount of
            equal signs than the start.".
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="T:Loretta.ContinueType">
            <summary>
            The type of continue the lua flavor being parsed has.
            </summary>
        </member>
        <member name="F:Loretta.ContinueType.None">
            <summary>
            No continue.
            </summary>
        </member>
        <member name="F:Loretta.ContinueType.Keyword">
            <summary>
            Continue is a keyword.
            </summary>
        </member>
        <member name="F:Loretta.ContinueType.ContextualKeyword">
            <summary>
            Continue is a contextual keyword (is only a keyword when used as a statement).
            </summary>
        </member>
        <member name="T:Loretta.LuaOptions">
            <summary>
            The options used by Loretta to adapt to the flavor of lua being parsed.
            </summary>
        </member>
        <member name="F:Loretta.LuaOptions.Lua51">
            <summary>
            The Lua 5.1 preset.
            </summary>
        </member>
        <member name="F:Loretta.LuaOptions.Lua52">
            <summary>
            The Lua 5.2 preset.
            </summary>
        </member>
        <member name="F:Loretta.LuaOptions.LuaJIT">
            <summary>
            The LuaJIT preset.
            </summary>
        </member>
        <member name="F:Loretta.LuaOptions.GMod">
            <summary>
            The GLua preset.
            </summary>
        </member>
        <member name="F:Loretta.LuaOptions.Roblox">
            <summary>
            The Luau preset.
            </summary>
        </member>
        <member name="F:Loretta.LuaOptions.All">
            <summary>
            The preset that sets everything to true and continue to <see
            cref="F:Loretta.ContinueType.ContextualKeyword" />.
            </summary>
        </member>
        <member name="P:Loretta.LuaOptions.AcceptBinaryNumbers">
            <summary>
            Whether to accept binary numbers (format: /0b[10]+/).
            </summary>
        </member>
        <member name="P:Loretta.LuaOptions.AcceptCCommentSyntax">
            <summary>
            Whether to accept C comment syntax (formats: "//..." and "/* ... */").
            </summary>
        </member>
        <member name="P:Loretta.LuaOptions.AcceptCompoundAssignment">
            <summary>
            Whether to accept compound assignment syntax (format: &lt;expr&gt; ("+=" | "-=" | "*=" |
            "/=" | "^=" | "%=" | "..=") &lt;expr&gt;).
            </summary>
        </member>
        <member name="P:Loretta.LuaOptions.AcceptEmptyStatements">
            <summary>
            Whether to accept empty statements (lone semicolons).
            </summary>
        </member>
        <member name="P:Loretta.LuaOptions.AcceptGModCOperators">
            <summary>
            Whether to accept the C operators addde in GLua (formats: "&amp;&amp;", "||", "!=", "!").
            </summary>
        </member>
        <member name="P:Loretta.LuaOptions.AcceptGoto">
            <summary>
            Whether to accept goto labels and statements.
            </summary>
        </member>
        <member name="P:Loretta.LuaOptions.AcceptHexEscapesInStrings">
            <summary>
            Whether to accept hexadecimal escapes in strings.
            </summary>
        </member>
        <member name="P:Loretta.LuaOptions.AcceptHexFloatLiterals">
            <summary>
            Whether to accept hexadecimal floating point literals (format: /0x[a-fA-F0-9]+(\.[a-fA-F0-9])?([+-]?p[0-9]+)/).
            </summary>
        </member>
        <member name="P:Loretta.LuaOptions.AcceptOctalNumbers">
            <summary>
            Whether to accept octal numbers (format: /0o[0-7]+/).
            </summary>
        </member>
        <member name="P:Loretta.LuaOptions.AcceptShebang">
            <summary>
            Whether to accept shebangs (format: "#!...") (currently accepted anywhere inside the file).
            </summary>
        </member>
        <member name="P:Loretta.LuaOptions.AcceptUnderlineInNumberLiterals">
            <summary>
            Whether to accept underlines in any number literals (will be ignored when parsing the number).
            </summary>
        </member>
        <member name="P:Loretta.LuaOptions.UseLuaJitIdentifierRules">
            <summary>
            Whether to use LuaJIT's identifier character rules (accepts any character greater than
            or equal to 0xF7).
            </summary>
        </member>
        <member name="P:Loretta.LuaOptions.ContinueType">
            <summary>
            The type of continue to be recognized by the parser.
            </summary>
        </member>
        <member name="M:Loretta.LuaOptions.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Loretta.ContinueType)">
            <summary>
            Initializes a new lua options set.
            </summary>
            <param name="acceptBinaryNumbers">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptBinaryNumbers" path="/summary" />
            </param>
            <param name="acceptCCommentSyntax">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptCCommentSyntax" path="/summary" />
            </param>
            <param name="acceptCompoundAssignment">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptCompoundAssignment" path="/summary" />
            </param>
            <param name="acceptEmptyStatements">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptEmptyStatements" path="/summary" />
            </param>
            <param name="acceptGModCOperators">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptGModCOperators" path="/summary" />
            </param>
            <param name="acceptGoto"><inheritdoc cref="P:Loretta.LuaOptions.AcceptGoto" path="/summary" /></param>
            <param name="acceptHexEscapesInStrings">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptHexEscapesInStrings" path="/summary" />
            </param>
            <param name="acceptHexFloatLiterals">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptHexFloatLiterals" path="/summary" />
            </param>
            <param name="acceptOctalNumbers">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptOctalNumbers" path="/summary" />
            </param>
            <param name="acceptShebang"><inheritdoc cref="P:Loretta.LuaOptions.AcceptShebang" path="/summary" /></param>
            <param name="acceptUnderlineInNumberLiterals">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptUnderlineInNumberLiterals" path="/summary" />
            </param>
            <param name="useLuaJitIdentifierRules">
            <inheritdoc cref="P:Loretta.LuaOptions.UseLuaJitIdentifierRules" path="/summary" />
            </param>
            <param name="continueType"><inheritdoc cref="P:Loretta.LuaOptions.ContinueType" path="/summary" /></param>
        </member>
        <member name="M:Loretta.LuaOptions.With(System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{Loretta.ContinueType})">
            <summary>
            Creates a new lua options changing the provided fields.
            </summary>
            <param name="acceptBinaryNumbers">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptBinaryNumbers" path="/summary" /> If null uses the value of <see
            cref="P:Loretta.LuaOptions.AcceptBinaryNumbers" />.
            </param>
            <param name="acceptCCommentSyntax">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptCCommentSyntax" path="/summary" /> If null uses the value of
            <see cref="P:Loretta.LuaOptions.AcceptCCommentSyntax" />.
            </param>
            <param name="acceptCompoundAssignment">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptCompoundAssignment" path="/summary" /> If null uses the value of
            <see cref="P:Loretta.LuaOptions.AcceptCompoundAssignment" />.
            </param>
            <param name="acceptEmptyStatements">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptEmptyStatements" path="/summary" /> If null uses the value of
            <see cref="P:Loretta.LuaOptions.AcceptEmptyStatements" />.
            </param>
            <param name="acceptGModCOperators">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptGModCOperators" path="/summary" /> If null uses the value of
            <see cref="P:Loretta.LuaOptions.AcceptGModCOperators" />.
            </param>
            <param name="acceptGoto">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptGoto" path="/summary" /> If null uses the value of <see
            cref="P:Loretta.LuaOptions.AcceptGoto" />.
            </param>
            <param name="acceptHexEscapesInStrings">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptHexEscapesInStrings" path="/summary" /> If null uses the value
            of <see cref="P:Loretta.LuaOptions.AcceptHexEscapesInStrings" />.
            </param>
            <param name="acceptHexFloatLiterals">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptHexFloatLiterals" path="/summary" /> If null uses the value of
            <see cref="P:Loretta.LuaOptions.AcceptHexFloatLiterals" />.
            </param>
            <param name="acceptOctalNumbers">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptOctalNumbers" path="/summary" /> If null uses the value of <see
            cref="P:Loretta.LuaOptions.AcceptOctalNumbers" />.
            </param>
            <param name="acceptShebang">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptShebang" path="/summary" /> If null uses the value of <see
            cref="P:Loretta.LuaOptions.AcceptShebang" />.
            </param>
            <param name="acceptUnderlineInNumberLiterals">
            <inheritdoc cref="P:Loretta.LuaOptions.AcceptUnderlineInNumberLiterals" path="/summary" /> If null uses the
            value of <see cref="P:Loretta.LuaOptions.AcceptUnderlineInNumberLiterals" />.
            </param>
            <param name="useLuaJitIdentifierRules">
            <inheritdoc cref="P:Loretta.LuaOptions.UseLuaJitIdentifierRules" path="/summary" /> If null uses the value of
            <see cref="P:Loretta.LuaOptions.UseLuaJitIdentifierRules" />.
            </param>
            <param name="continueType">
            <inheritdoc cref="P:Loretta.LuaOptions.ContinueType" path="/summary" /> If null uses the value of <see
            cref="P:Loretta.LuaOptions.ContinueType" />.
            </param>
            <returns></returns>
        </member>
        <member name="T:Loretta.Parsing.ASTNodeFactory">
            <summary>
            The factory for AST nodes.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.ASTNodeFactory.Identifier(System.String,System.Nullable{GParse.SourceRange})">
            <summary>
            Creates a new <see cref="T:Loretta.Parsing.AST.IdentifierExpression" /> node.
            </summary>
            <param name="identifier">The node's identifier.</param>
            <param name="range">The range of the identifier.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.ASTNodeFactory.BooleanExpression(System.Boolean,System.Nullable{GParse.SourceRange})">
            <summary>
            Creates a new <see cref="T:Loretta.Parsing.AST.BooleanExpression" /> node.
            </summary>
            <param name="value">The boolean value.</param>
            <param name="range">The range of the boolean raw value.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.ASTNodeFactory.NumberExpression(System.Double,System.String,System.Nullable{GParse.SourceRange})">
            <summary>
            Creates a new <see cref="T:Loretta.Parsing.AST.NumberExpression" /> node.
            </summary>
            <param name="value">The numeric value of the expression.</param>
            <param name="rawValue">The string form of the numeric value.</param>
            <param name="range">The range of the string form of the numeric value.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.ASTNodeFactory.ShortString(System.String,System.String,System.Nullable{GParse.SourceRange})">
            <summary>
            Creates a new short string <see cref="T:Loretta.Parsing.AST.StringExpression" /> node.
            </summary>
            <param name="value">The value of the short string.</param>
            <param name="rawValue">The string form of the short string (including delimiters).</param>
            <param name="range">The range of the string form of the short string.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.ASTNodeFactory.LongString(System.String,System.String,System.Nullable{GParse.SourceRange})">
            <summary>
            Creates a new long string <see cref="T:Loretta.Parsing.AST.StringExpression" /> node.
            </summary>
            <param name="value">The value of the short string.</param>
            <param name="rawValue">The string form of the short string (including delimiters).</param>
            <param name="range">The range of the string form of the short string.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.ASTNodeFactory.Nil(System.Nullable{GParse.SourceRange})">
            <summary>
            Creates a new <see cref="T:Loretta.Parsing.AST.NilExpression" /> node.
            </summary>
            <param name="range">The range of the nil keyword.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.ASTNodeFactory.UnaryOperation(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression)">
            <summary>
            Creates a new prefix <see cref="T:Loretta.Parsing.AST.UnaryOperationExpression" /> node.
            </summary>
            <param name="op">The operation's operator.</param>
            <param name="expression">The operation's operand.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.ASTNodeFactory.UnaryOperation(Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Creates a new postfix <see cref="T:Loretta.Parsing.AST.UnaryOperationExpression" /> node.
            </summary>
            <param name="expression">The operation's operand.</param>
            <param name="op">The operation's operator.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.ASTNodeFactory.IfStatement(System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.IfClause},Loretta.Parsing.AST.StatementList)">
            <summary>
            Creates a new <see cref="T:Loretta.Parsing.AST.IfStatement" /> node.
            </summary>
            <param name="clauses">The if statement's clauses.</param>
            <param name="elseBlock">The else block (if any).</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.ASTNodeFactory.IfClause(Loretta.Parsing.AST.Expression,Loretta.Parsing.AST.StatementList)">
            <summary>
            Creates a new <see cref="T:Loretta.Parsing.AST.IfClause" />.
            </summary>
            <param name="condition">The clause's condition.</param>
            <param name="body">The clause's body.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.ASTNodeFactory.StatementList(Loretta.Parsing.Scope,Loretta.Parsing.AST.Statement[])">
            <summary>
            Creates a new <see cref="T:Loretta.Parsing.AST.StatementList" />.
            </summary>
            <param name="scope">The list's scope.</param>
            <param name="statements">The list's statements.</param>
            <returns></returns>
        </member>
        <member name="T:Loretta.Parsing.AST.AnonymousFunctionExpression">
            <summary>
            Represents an anonymous function expression.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.AnonymousFunctionExpression.Arguments">
            <summary>
            This function's arguments.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.AnonymousFunctionExpression.Body">
            <summary>
            This function's body.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.AnonymousFunctionExpression.IsConstant">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.AnonymousFunctionExpression.ConstantValue">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Parsing.AST.AnonymousFunctionExpression.#ctor(System.Collections.Generic.IEnumerable{GParse.Lexing.Token{Loretta.Lexing.LuaTokenType}},System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.Expression},Loretta.Parsing.AST.StatementList)">
            <summary>
            Initializes a new anonymous function expression.
            </summary>
            <param name="tokens">The function's tokens.</param>
            <param name="arguments">The function's arguments.</param>
            <param name="body">The function's body.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.AnonymousFunctionExpression.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.AnonymousFunctionExpression.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.AssignmentStatement">
            <summary>
            Represents an assignment statement.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.AssignmentStatement.Variables">
            <summary>
            This assignment's variables. May have a larger or smaller number of entries than the
            <see cref="P:Loretta.Parsing.AST.AssignmentStatement.Values" />.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.AssignmentStatement.Values">
            <summary>
            This assignment's values. May have a larger or smaller number of entries than the the
            <see cref="P:Loretta.Parsing.AST.AssignmentStatement.Variables" />.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.AssignmentStatement.#ctor(System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.Expression},System.Collections.Generic.IEnumerable{GParse.Lexing.Token{Loretta.Lexing.LuaTokenType}},GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.Expression},System.Collections.Generic.IEnumerable{GParse.Lexing.Token{Loretta.Lexing.LuaTokenType}})">
            <summary>
            Initializes a new assignment statement.
            </summary>
            <param name="variables">The assignment variables.</param>
            <param name="variablesCommas">The assignment variables' commas.</param>
            <param name="equals">The assignment equals sign.</param>
            <param name="values">The assignment values.</param>
            <param name="valuesCommas">The assignment values' commas.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.AssignmentStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.AssignmentStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.BinaryOperationExpression">
            <summary>
            Represents a binary operation expression.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.BinaryOperationExpression.Left">
            <summary>
            The expression on the left side of the operator.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.BinaryOperationExpression.Operator">
            <summary>
            The operation's operator.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.BinaryOperationExpression.Right">
            <summary>
            The expression on the right side of the operator.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.BinaryOperationExpression.IsConstant">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.BinaryOperationExpression.ConstantValue">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Parsing.AST.BinaryOperationExpression.#ctor(Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression)">
            <summary>
            Initializes a new binary operation expression.
            </summary>
            <param name="left">The expression on the left side of the operator.</param>
            <param name="op">The operation's operator.</param>
            <param name="right">The expression on the right side of the operator.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.BinaryOperationExpression.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.BinaryOperationExpression.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.BooleanExpression">
            <summary>
            Represents a boolean literal expression.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.AST.BooleanExpression.Token">
            <summary>
            The boolean literal token.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.BooleanExpression.Value">
            <summary>
            The boolean value of the literal.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.BooleanExpression.IsConstant">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.BooleanExpression.ConstantValue">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Parsing.AST.BooleanExpression.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},System.Boolean)">
            <summary>
            Initializes a new boolean expression.
            </summary>
            <param name="token">The boolean literal token.</param>
            <param name="value">The boolean value of the literal.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.BooleanExpression.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.BooleanExpression.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.BreakStatement">
            <summary>
            Represents a break statement.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.BreakStatement.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new break statement.
            </summary>
            <param name="breakKw"></param>
        </member>
        <member name="P:Loretta.Parsing.AST.BreakStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.BreakStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.CompoundAssignmentStatement">
            <summary>
            Represents a compound assignment statement.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.CompoundAssignmentStatement.Assignee">
            <summary>
            The expression being assigned to.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.CompoundAssignmentStatement.OperatorToken">
            <summary>
            The compound assignment operator.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.CompoundAssignmentStatement.ValueExpression">
            <summary>
            The value being assigned.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.CompoundAssignmentStatement.#ctor(Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression)">
            <summary>
            Initializes a new compound assignment statement.
            </summary>
            <param name="assignee">The expression being assigned to.</param>
            <param name="operatorToken">The compound assignment operator.</param>
            <param name="valueExpression">The expression value.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.CompoundAssignmentStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.CompoundAssignmentStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.ContinueStatement">
            <summary>
            Represents a continue statement.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.ContinueStatement.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new continue statement.
            </summary>
            <param name="continueKw">The continue keyword.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.ContinueStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.ContinueStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.DoStatement">
            <summary>
            A do statement.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.DoStatement.Body">
            <summary>
            The do statement body.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.DoStatement.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.StatementList,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new do statement.
            </summary>
            <param name="doKw">The do keyword.</param>
            <param name="body">The do statement body.</param>
            <param name="endKw">The end keyword.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.DoStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.DoStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.EmptyStatement">
            <summary>
            Represents an empty statement.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.EmptyStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.EmptyStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.Expression">
            <summary>
            The base class for an expression node.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.Expression.IsConstant">
            <summary>
            Whether this expression has a constant value.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.Expression.ConstantValue">
            <summary>
            This expression's constant value.
            </summary>
        </member>
        <member name="T:Loretta.Parsing.AST.ExpressionStatement">
            <summary>
            Represents an expression as a statement.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.ExpressionStatement.Expression">
            <summary>
            The expression being used as a statement.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.ExpressionStatement.#ctor(Loretta.Parsing.AST.Expression)">
            <summary>
            Initializes a new expression statement.
            </summary>
            <param name="expression">The statement's expression.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.ExpressionStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.ExpressionStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.FunctionCallExpression">
            <summary>
            Represents a function call expression.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.FunctionCallExpression.Function">
            <summary>
            The expression being called.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.FunctionCallExpression.Arguments">
            <summary>
            The call's arguments.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.FunctionCallExpression.HasParenthesis">
            <summary>
            Whether the call has parenthesis.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.FunctionCallExpression.IsConstant">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.FunctionCallExpression.ConstantValue">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Parsing.AST.FunctionCallExpression.#ctor(Loretta.Parsing.AST.Expression,Loretta.Parsing.AST.Expression)">
            <summary>
            Initializes a new function call expression without parenthesis.
            </summary>
            <param name="function">The expression being called.</param>
            <param name="argument">The call's argument.</param>
        </member>
        <member name="M:Loretta.Parsing.AST.FunctionCallExpression.#ctor(Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.Expression},System.Collections.Generic.IEnumerable{GParse.Lexing.Token{Loretta.Lexing.LuaTokenType}},GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new function call expression with parenthesis.
            </summary>
            <param name="function">The expression being called.</param>
            <param name="lparen">The left parenthesis token.</param>
            <param name="arguments">The call's arguments.</param>
            <param name="commas">The arguments' commas.</param>
            <param name="rparen">The right parenthesis token.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.FunctionCallExpression.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.FunctionCallExpression.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.FunctionDefinitionStatement">
            <summary>
            Represents a function definition statement.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.FunctionDefinitionStatement.IsLocal">
            <summary>
            Whether the function is local.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.FunctionDefinitionStatement.Name">
            <summary>
            The function name. Can be an <see cref="T:Loretta.Parsing.AST.IndexExpression" /> or an <see
            cref="T:Loretta.Parsing.AST.IdentifierExpression" />.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.FunctionDefinitionStatement.Arguments">
            <summary>
            The function's arguments. Can be an <see cref="T:Loretta.Parsing.AST.IdentifierExpression" /> or a <see
            cref="T:Loretta.Parsing.AST.VarArgExpression" />.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.FunctionDefinitionStatement.Body">
            <summary>
            The function's body.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.FunctionDefinitionStatement.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.Expression},System.Collections.Generic.IEnumerable{GParse.Lexing.Token{Loretta.Lexing.LuaTokenType}},GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.StatementList,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new function definition statement.
            </summary>
            <param name="functionKw">The function keyword token.</param>
            <param name="name">The function's name.</param>
            <param name="lparen">The left parenthesis token.</param>
            <param name="arguments">The argument names.</param>
            <param name="commas">The arguments' commas.</param>
            <param name="rparen">The right parenthesis token.</param>
            <param name="body">The function's body.</param>
            <param name="endKw">The end keyword token.</param>
        </member>
        <member name="M:Loretta.Parsing.AST.FunctionDefinitionStatement.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.Expression},System.Collections.Generic.IEnumerable{GParse.Lexing.Token{Loretta.Lexing.LuaTokenType}},GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.StatementList,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new local function definition statement.
            </summary>
            <param name="localKw">The local keyword token.</param>
            <param name="functionKw">The function keyword token.</param>
            <param name="name">The function's name.</param>
            <param name="lparen">The left parenthesis token.</param>
            <param name="arguments">The function's arguments.</param>
            <param name="commas">The function's arguments' commas.</param>
            <param name="rparen">The right parenthesis token.</param>
            <param name="body">The function's body.</param>
            <param name="endKw">The end keyword token.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.FunctionDefinitionStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.FunctionDefinitionStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.GenericForLoopStatement">
            <summary>
            Represents a generic for loop statement.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.GenericForLoopStatement.Scope">
            <summary>
            The for loop's scope.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.GenericForLoopStatement.Variables">
            <summary>
            The for loop's iteration variables.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.GenericForLoopStatement.Expressions">
            <summary>
            The for loop's expressions.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.GenericForLoopStatement.Body">
            <summary>
            The for loop's body.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.GenericForLoopStatement.#ctor(Loretta.Parsing.Scope,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.IdentifierExpression},System.Collections.Generic.IEnumerable{GParse.Lexing.Token{Loretta.Lexing.LuaTokenType}},GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.Expression},GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.StatementList,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new generic for loop statement.
            </summary>
            <param name="scope">The scope.</param>
            <param name="forKw">The for keyword.</param>
            <param name="variables">The variables.</param>
            <param name="commas">The commas.</param>
            <param name="inKw">The in keyword.</param>
            <param name="expressions">The expressions.</param>
            <param name="doKw">The do keyword.</param>
            <param name="body">The loop's body.</param>
            <param name="endKw">The end keyword.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.GenericForLoopStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.GenericForLoopStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.GotoLabelStatement">
            <summary>
            Represents a goto label statement.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.GotoLabelStatement.Label">
            <summary>
            The goto label.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.GotoLabelStatement.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.GotoLabel,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new goto label statement.
            </summary>
            <param name="ldelim">The left delimiter token.</param>
            <param name="label">The goto label.</param>
            <param name="ident">The identifier token.</param>
            <param name="rdelim">The right delimiter token.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.GotoLabelStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.GotoLabelStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.GotoStatement">
            <summary>
            Represents a goto label.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.GotoStatement.Target">
            <summary>
            The goto label target.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.GotoStatement.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.GotoLabel)">
            <summary>
            Initializes a new goto statement.
            </summary>
            <param name="gotoKw">The goto keyword.</param>
            <param name="identKw">The identifier.</param>
            <param name="target">The goto label.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.GotoStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.GotoStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.GroupedExpression">
            <summary>
            Represents a grouped/parenthesized expression.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.GroupedExpression.InnerExpression">
            <summary>
            The wrapped expression.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.GroupedExpression.IsConstant">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.GroupedExpression.ConstantValue">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Parsing.AST.GroupedExpression.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new grouped expression.
            </summary>
            <param name="lparen">The left parenthesis token.</param>
            <param name="inner">The wrapped expression.</param>
            <param name="rparen">The right parenthesis.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.GroupedExpression.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.GroupedExpression.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.IdentifierExpression">
            <summary>
            Represents an identifier expression.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.AST.IdentifierExpression.Variable">
            <summary>
            The expression's variable.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.IdentifierExpression.Identifier">
            <summary>
            The identifier's identifier.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.IdentifierExpression.IsConstant">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.IdentifierExpression.ConstantValue">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Parsing.AST.IdentifierExpression.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.Variable)">
            <summary>
            Initializes an new identifier expression.
            </summary>
            <param name="token">The identifier token.</param>
            <param name="variable">The identifier variable.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.IdentifierExpression.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.IdentifierExpression.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.IfClause">
            <summary>
            Represents an if clause.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.IfClause.Condition">
            <summary>
            The clause's condition.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.IfClause.Body">
            <summary>
            The clause's body.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.IfClause.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.StatementList)">
            <summary>
            Initializes a new if clause.
            </summary>
            <param name="preCondTok">The clause's if/elseif token.</param>
            <param name="condition">The clause's condition.</param>
            <param name="thenKw">The clause's then token.</param>
            <param name="body">The clause's body.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.IfClause.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.IfClause.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.IfStatement">
            <summary>
            Represents an if statement.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.IfStatement.Clauses">
            <summary>
            The if/elseif statement clauses.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.IfStatement.ElseBlock">
            <summary>
            The else block body.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.IfStatement.#ctor(System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.IfClause},GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new if statement.
            </summary>
            <param name="clauses">The if clauses.</param>
            <param name="endTok">The end keyword token.</param>
        </member>
        <member name="M:Loretta.Parsing.AST.IfStatement.#ctor(System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.IfClause},GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.StatementList,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new if statemnet.
            </summary>
            <param name="clauses">The if clauses</param>
            <param name="elseKw">The else keyword.</param>
            <param name="elseBlock">The else block.</param>
            <param name="endTok">The end token.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.IfStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.IfStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.IndexType">
            <summary>
            The type of indexing this is
            </summary>
        </member>
        <member name="F:Loretta.Parsing.AST.IndexType.Indexer">
            <summary>
            Indexing done with an expression ('[', expr, ']').
            </summary>
        </member>
        <member name="F:Loretta.Parsing.AST.IndexType.Member">
            <summary>
            Indexing done with an identifier ('.' ident).
            </summary>
        </member>
        <member name="F:Loretta.Parsing.AST.IndexType.Method">
            <summary>
            Function call done on an indexing done with an identifier (':' ident &lt;funccall&gt;).
            </summary>
        </member>
        <member name="T:Loretta.Parsing.AST.IndexExpression">
            <summary>
            Represents an indexing expression.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.IndexExpression.Type">
            <summary>
            The type of indexing operation being done.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.IndexExpression.Indexee">
            <summary>
            The expression being indexed.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.IndexExpression.Indexer">
            <summary>
            THe expression being used to index.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.IndexExpression.IsConstant">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.IndexExpression.ConstantValue">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Parsing.AST.IndexExpression.#ctor(Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new expression-based indexing operation.
            </summary>
            <param name="indexee">The expresion being indexed.</param>
            <param name="lbracket">The left bracket token.</param>
            <param name="indexer">The expression being used to index.</param>
            <param name="rbracket">The right bracket token.</param>
        </member>
        <member name="M:Loretta.Parsing.AST.IndexExpression.#ctor(Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.IdentifierExpression)">
            <summary>
            Initializes a new identifier-based indexing expression.
            </summary>
            <param name="indexee">The expression being indexed.</param>
            <param name="separator">The indexing operation separator.</param>
            <param name="indexer">The identifier being used to index.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.IndexExpression.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.IndexExpression.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.LocalVariableDeclarationStatement">
            <summary>
            Represents a local variable declaration.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.LocalVariableDeclarationStatement.Identifiers">
            <summary>
            The variable names being assigned to.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.LocalVariableDeclarationStatement.Values">
            <summary>
            The values being assigned to the variables.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.LocalVariableDeclarationStatement.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.IdentifierExpression},System.Collections.Generic.IEnumerable{GParse.Lexing.Token{Loretta.Lexing.LuaTokenType}})">
            <summary>
            Initializes a new local variable declaration.
            </summary>
            <param name="localKw">The local keyword.</param>
            <param name="identifiers">The variable names.</param>
            <param name="commas">The variable names separator commas.</param>
        </member>
        <member name="M:Loretta.Parsing.AST.LocalVariableDeclarationStatement.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.IdentifierExpression},System.Collections.Generic.IEnumerable{GParse.Lexing.Token{Loretta.Lexing.LuaTokenType}},GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.Expression},System.Collections.Generic.IEnumerable{GParse.Lexing.Token{Loretta.Lexing.LuaTokenType}})">
            <summary>
            Initializes a new local variable declaration.
            </summary>
            <param name="localKw">The local keyword.</param>
            <param name="identifiers">The variable names.</param>
            <param name="identifiersCommas">The variable names separator commas.</param>
            <param name="equals">The equals sign.</param>
            <param name="values">The values being assigned.</param>
            <param name="valuesCommas">The values separator commas.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.LocalVariableDeclarationStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.LocalVariableDeclarationStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.LuaASTNode">
            <summary>
            The base class for all lua AST nodes.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.LuaASTNode.Tokens">
            <summary>
            The tokens contained in this node.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.LuaASTNode.Children">
            <summary>
            The children contained in this node.
            </summary>
        </member>
        <member name="T:Loretta.Parsing.AST.NilExpression">
            <summary>
            Represents a nil literal expression.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.NilExpression.IsConstant">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.NilExpression.ConstantValue">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Parsing.AST.NilExpression.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new nil literal expression.
            </summary>
            <param name="tok"></param>
        </member>
        <member name="P:Loretta.Parsing.AST.NilExpression.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.NilExpression.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.NumberExpression">
            <summary>
            Represents a number literal expression.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.AST.NumberExpression.Value">
            <summary>
            The value of the number expression.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.NumberExpression.IsConstant">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.NumberExpression.ConstantValue">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Parsing.AST.NumberExpression.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new number literal expression.
            </summary>
            <param name="token"></param>
        </member>
        <member name="P:Loretta.Parsing.AST.NumberExpression.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.NumberExpression.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.NumericForLoopStatement">
            <summary>
            Represents a numeric for loop statement.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.NumericForLoopStatement.Scope">
            <summary>
            The scope.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.NumericForLoopStatement.Variable">
            <summary>
            The iteration variable.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.NumericForLoopStatement.Initial">
            <summary>
            The initial value.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.NumericForLoopStatement.Final">
            <summary>
            The final value.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.NumericForLoopStatement.Step">
            <summary>
            The iteration step increment value.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.NumericForLoopStatement.Body">
            <summary>
            The body.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.NumericForLoopStatement.#ctor(Loretta.Parsing.Scope,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.IdentifierExpression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.StatementList,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new numeric for loop statement.
            </summary>
            <param name="scope">The scope.</param>
            <param name="forKw">The for keyword token.</param>
            <param name="variable">The iteration variable.</param>
            <param name="equals">The equals sign token.</param>
            <param name="initial">The initial value.</param>
            <param name="comma1">The first comma token.</param>
            <param name="final">The final value.</param>
            <param name="doKw">The do keyword.</param>
            <param name="body">The body.</param>
            <param name="endKw">The end keyword.</param>
        </member>
        <member name="M:Loretta.Parsing.AST.NumericForLoopStatement.#ctor(Loretta.Parsing.Scope,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.IdentifierExpression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.StatementList,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new numeric for loop statement.
            </summary>
            <param name="scope">The scope.</param>
            <param name="forKw">The for keyword token.</param>
            <param name="variable">The iteration variable.</param>
            <param name="equals">The equals sign token.</param>
            <param name="initial">The initial value.</param>
            <param name="comma1">The first comma token.</param>
            <param name="final">The final value.</param>
            <param name="comma2">The second comma token.</param>
            <param name="step">The step increment value.</param>
            <param name="doKw">The do keyword.</param>
            <param name="body">The body.</param>
            <param name="endKw">The end keyword.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.NumericForLoopStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.NumericForLoopStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.RepeatUntilStatement">
            <summary>
            Represents a repeat until statement.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.RepeatUntilStatement.Scope">
            <summary>
            The scope.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.RepeatUntilStatement.Body">
            <summary>
            The body.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.RepeatUntilStatement.Condition">
            <summary>
            The condition.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.RepeatUntilStatement.#ctor(Loretta.Parsing.Scope,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.StatementList,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression)">
            <summary>
            Initializes a new repeat until statement.
            </summary>
            <param name="scope">The scope.</param>
            <param name="repeatKw">The repeat keyword.</param>
            <param name="body">The body.</param>
            <param name="untilKw">The until keyword.</param>
            <param name="condition">The condition expression.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.RepeatUntilStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.RepeatUntilStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.ReturnStatement">
            <summary>
            Represents a return statement.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.ReturnStatement.Values">
            <summary>
            The values being returned.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.ReturnStatement.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.Expression},System.Collections.Generic.IEnumerable{GParse.Lexing.Token{Loretta.Lexing.LuaTokenType}})">
            <summary>
            Initializes a new return statement.
            </summary>
            <param name="returnKw">The return keyword token.</param>
            <param name="values">The values being returned.</param>
            <param name="commas">The values being returned comma separators.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.ReturnStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.ReturnStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.Statement">
            <summary>
            The base class for a statement.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.Statement.Semicolon">
            <summary>
            The statement's semicolon. Null if none.
            </summary>
        </member>
        <member name="T:Loretta.Parsing.AST.StatementList">
            <summary>
            Represents a list of statements.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.AST.StatementList.Scope">
            <summary>
            The scope.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.AST.StatementList.Body">
            <summary>
            The statements in this list.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.StatementList.#ctor(Loretta.Parsing.Scope,System.Collections.Generic.IEnumerable{Loretta.Parsing.AST.Statement})">
            <summary>
            Initializes a list of statement.
            </summary>
            <param name="scope">The scope.</param>
            <param name="statements">The statements in this list.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.StatementList.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.StatementList.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.StringExpression">
            <summary>
            Represents a string literal expression.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.StringExpression.IsLong">
            <summary>
            Whether this is a long/literal string literal.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.StringExpression.Value">
            <summary>
            The string's value.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.StringExpression.IsConstant">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.StringExpression.ConstantValue">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Parsing.AST.StringExpression.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new string literal expression.
            </summary>
            <param name="token">The string literal token.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.StringExpression.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.StringExpression.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.TableConstructorExpression">
            <summary>
            Represents a table literal expression.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.TableConstructorExpression.Fields">
            <summary>
            The table fields.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.TableConstructorExpression.IsConstant">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.TableConstructorExpression.ConstantValue">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Parsing.AST.TableConstructorExpression.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Tables.TableField[],GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a table literal expression.
            </summary>
            <param name="lcurly">The left curly bracket token.</param>
            <param name="fields">The table fields.</param>
            <param name="rcurly">The right curly bracket token.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.TableConstructorExpression.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.TableConstructorExpression.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.Tables.TableFieldKeyType">
            <summary>
            The type of key of the <see cref="T:Loretta.Parsing.AST.Tables.TableField" />.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.AST.Tables.TableFieldKeyType.None">
            <summary>
            No key (sequential). Format: &lt;expr&gt;.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.AST.Tables.TableFieldKeyType.Identifier">
            <summary>
            An identifier key. Format: &lt;ident&gt; = &lt;expr&gt;.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.AST.Tables.TableFieldKeyType.Expression">
            <summary>
            An expression. Format: [&lt;expr&gt;] = &lt;expr&gt;.
            </summary>
        </member>
        <member name="T:Loretta.Parsing.AST.Tables.TableField">
            <summary>
            Represents a table field.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.Tables.TableField.KeyType">
            <summary>
            The type of key this table field has.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.Tables.TableField.Key">
            <summary>
            The key of the table entry. <see langword="null" /> if the field is a sequential one, an
            <see cref="T:Loretta.Parsing.AST.IdentifierExpression" /> if the key was an identifier or some other
            expression if it was the bracket-based index.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.Tables.TableField.Value">
            <summary>
            The value of the table entry.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.Tables.TableField.Delimiter">
            <summary>
            The delimiter of the table field
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.Tables.TableField.#ctor(Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Creates a sequential table field.
            </summary>
            <param name="value">The table field's value.</param>
            <param name="delim">The table field's delimiter.</param>
        </member>
        <member name="M:Loretta.Parsing.AST.Tables.TableField.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes an identifier-keyed field.
            </summary>
            <param name="ident">The table field's identifier key.</param>
            <param name="equals">The table field's equals sign.</param>
            <param name="value">The table field's value.</param>
            <param name="delim">The table field's delimiter.</param>
        </member>
        <member name="M:Loretta.Parsing.AST.Tables.TableField.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a expression-keyed field.
            </summary>
            <param name="lbracket">The table field's left bracket '['.</param>
            <param name="key">The table field's key expression.</param>
            <param name="rbracket">The table field's right bracket ']'.</param>
            <param name="equals">The table field's equals sign.</param>
            <param name="value">The table field's value expression.</param>
            <param name="delim">The table field's delimiter.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.Tables.TableField.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.Tables.TableField.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.UnaryOperationFix">
            <summary>
            The fix of the unary operation.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.AST.UnaryOperationFix.Prefix">
            <summary>
            A prefix operation.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.AST.UnaryOperationFix.Postfix">
            <summary>
            A suffix/postfix operation.
            </summary>
        </member>
        <member name="T:Loretta.Parsing.AST.UnaryOperationExpression">
            <summary>
            Represents a unary operation expression.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.UnaryOperationExpression.Fix">
            <summary>
            The unary operation's fix.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.UnaryOperationExpression.Operator">
            <summary>
            The operation's operator.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.UnaryOperationExpression.Operand">
            <summary>
            The operation's operand.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.UnaryOperationExpression.IsConstant">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.UnaryOperationExpression.ConstantValue">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Parsing.AST.UnaryOperationExpression.#ctor(Loretta.Parsing.AST.UnaryOperationFix,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression)">
            <summary>
            Initializes a new unary operation expression.
            </summary>
            <param name="fix">The operation's fix.</param>
            <param name="op">The operator.</param>
            <param name="expr">The operation's operand.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.UnaryOperationExpression.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.UnaryOperationExpression.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.VarArgExpression">
            <summary>
            Represents a vararg expression.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.VarArgExpression.IsConstant">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.VarArgExpression.ConstantValue">
            <inheritdoc />
        </member>
        <member name="M:Loretta.Parsing.AST.VarArgExpression.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new vararg expression.
            </summary>
            <param name="token">The vararg token.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.VarArgExpression.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.VarArgExpression.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.AST.WhileLoopStatement">
            <summary>
            Represents a while loop statement.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.WhileLoopStatement.Condition">
            <summary>
            The loop's condition.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.AST.WhileLoopStatement.Body">
            <summary>
            The loop's body.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.AST.WhileLoopStatement.#ctor(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.StatementList,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType})">
            <summary>
            Initializes a new while loop statement.
            </summary>
            <param name="whileKw">The while keyword token.</param>
            <param name="condition">The loop's condition.</param>
            <param name="doKw">The do keyword token.</param>
            <param name="body">The loop's body.</param>
            <param name="endKw">The end keyword token.</param>
        </member>
        <member name="P:Loretta.Parsing.AST.WhileLoopStatement.Tokens">
            <inheritdoc />
        </member>
        <member name="P:Loretta.Parsing.AST.WhileLoopStatement.Children">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.GotoLabel">
            <summary>
            Represents a goto label.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.GotoLabel.Scope">
            <summary>
            The label's containing scope.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.GotoLabel.Identifier">
            <summary>
            The label's identifier.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.GotoLabel.#ctor(Loretta.Parsing.Scope,System.String)">
            <summary>
            Initializes a new goto label.
            </summary>
            <param name="scope"><inheritdoc cref="P:Loretta.Parsing.GotoLabel.Scope" /></param>
            <param name="identifier"><inheritdoc cref="P:Loretta.Parsing.GotoLabel.Identifier" /></param>
        </member>
        <member name="T:Loretta.Parsing.LuaParser">
            <summary>
            The lua parser class.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.LuaParser.LuaOptions">
            <summary>
            The lua options used by this parser.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.EnterScope(System.Boolean)">
            <summary>
            Creates and enters a new scope.
            </summary>
            <param name="isFuntion">Whether the scope is a function's.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.GetOrCreateVariable(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType}@,Loretta.Parsing.Scope.FindMode)">
            <summary>
            Retrieves or creates a variable.
            </summary>
            <param name="token">The token that generated the variable.</param>
            <param name="findMode">The scope search mode.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.GetOrCreateLabel(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType}@,Loretta.Parsing.Scope.FindMode)">
            <summary>
            Retrieves or creates a goto label.
            </summary>
            <param name="token">The token that generated the goto label.</param>
            <param name="findMode">The scope search mode.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.LeaveScope">
            <summary>
            Returns and leaves the current scope.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.#ctor(Loretta.LuaOptions,GParse.Lexing.ITokenReader{Loretta.Lexing.LuaTokenType},GParse.Parsing.PrattParserModuleTree{Loretta.Lexing.LuaTokenType,GParse.Parsing.Parselets.IPrefixParselet{Loretta.Lexing.LuaTokenType,Loretta.Parsing.AST.Expression}},GParse.Parsing.PrattParserModuleTree{Loretta.Lexing.LuaTokenType,GParse.Parsing.Parselets.IInfixParselet{Loretta.Lexing.LuaTokenType,Loretta.Parsing.AST.Expression}},System.IProgress{GParse.Diagnostic})">
            <summary>
            Initializes a new lua parser.
            </summary>
            <param name="luaOptions">The lua options to use.</param>
            <param name="tokenReader">The token reader to use</param>
            <param name="prefixModules">The prefix module tree.</param>
            <param name="infixModules">The infix module tree.</param>
            <param name="diagnosticEmitter">The diagnostic emitter.</param>
        </member>
        <member name="F:Loretta.Parsing.LuaParser.terminals">
            <summary>
            The list of terminal token ids.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.LuaParser.compoundAssignmentOperatorIds">
            <summary>
            The compound assignment operator token ids.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.HasTerminalAhead">
            <summary>
            Whether the next token is a terminal.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseExpression">
            <summary>
            Attempts to parse an expression and throws a <see cref="T:GParse.Errors.FatalParsingException" /> if
            unable to.
            </summary>
            <returns></returns>
            <exception cref="T:GParse.Errors.FatalParsingException">Thrown when the expression parsing fails.</exception>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseIdentifierExpression(Loretta.Parsing.Scope.FindMode)">
            <summary>
            Parses an identifier expression.
            </summary>
            <param name="findMode">The finding mode to use when getting a variable for the identifier.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseFunctionName">
            <summary>
            Parses a function name.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseDoStatement">
            <summary>
            Parses a <see cref="T:Loretta.Parsing.AST.DoStatement" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseFunctionDefinitionStatement">
            <summary>
            Parses a (local or not) function definition statement.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseIfStatement">
            <summary>
            Parses an <see cref="T:Loretta.Parsing.AST.IfStatement" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseLocalVariableDeclarationStatement">
            <summary>
            Parses a <see cref="T:Loretta.Parsing.AST.LocalVariableDeclarationStatement" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseGotoLabelStatement">
            <summary>
            Parses a <see cref="T:Loretta.Parsing.AST.GotoLabelStatement" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseAssignmentStatement(Loretta.Parsing.AST.Expression)">
            <summary>
            Parses an <see cref="T:Loretta.Parsing.AST.AssignmentStatement" />.
            </summary>
            <param name="expr">The first expression on the left side of assignment.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseCompoundAssignmentStatement(Loretta.Parsing.AST.Expression)">
            <summary>
            Parses a <see cref="T:Loretta.Parsing.AST.CompoundAssignmentStatement" />.
            </summary>
            <param name="assignee">The expression on the left side of the assignment.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseWhileLoopStatement">
            <summary>
            Parses a <see cref="T:Loretta.Parsing.AST.WhileLoopStatement" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseRepeatUntilLoopStatement">
            <summary>
            Parses a <see cref="T:Loretta.Parsing.AST.RepeatUntilStatement" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseGenericForLoopStatement">
            <summary>
            Parses a <see cref="T:Loretta.Parsing.AST.GenericForLoopStatement" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseNumericForLoopStatement">
            <summary>
            Parses a <see cref="T:Loretta.Parsing.AST.NumericForLoopStatement" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseReturnStatement">
            <summary>
            Parses a <see cref="T:Loretta.Parsing.AST.ReturnStatement" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseStatement">
            <summary>
            Parses a <see cref="T:Loretta.Parsing.AST.Statement" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseStatementList(Loretta.Parsing.Scope)">
            <summary>
            Parses a <see cref="T:Loretta.Parsing.AST.StatementList" />.
            </summary>
            <param name="scope">The statement list's scope.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.ParseScopedStatementList(System.Boolean)">
            <summary>
            Parses a <see cref="T:Loretta.Parsing.AST.StatementList" /> with a dedicated scope.
            </summary>
            <param name="isFunction">Whether the scope is a function's.</param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParser.Parse">
            <summary>
            Parses the entire provided code.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Loretta.Parsing.LuaParserBuilder">
            <summary>
            The lua parser builder.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.LuaParserBuilder.LuaOptions">
            <summary>
            The lua options to be used by this builder and the parsers it builds.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.LuaParserBuilder.#ctor(Loretta.LuaOptions)">
            <summary>
            Initializes a new lua parser builder.
            </summary>
            <param name="luaOptions">The lua options to be used.</param>
        </member>
        <member name="M:Loretta.Parsing.LuaParserBuilder.BinaryOperatorFactory(Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,Loretta.Parsing.AST.Expression@)">
            <summary>
            The factory method for <see cref="T:Loretta.Parsing.AST.BinaryOperationExpression" /> nodes.
            </summary>
            <param name="left">The operand on the left side.</param>
            <param name="op">The operator.</param>
            <param name="right">The operand on the right side.</param>
            <param name="expression">The created <see cref="T:Loretta.Parsing.AST.BinaryOperationExpression" />.</param>
            <returns><see langword="true" /></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParserBuilder.PrefixOperatorFactory(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression,Loretta.Parsing.AST.Expression@)">
            <summary>
            The factory method for prefix <see cref="T:Loretta.Parsing.AST.UnaryOperationExpression" /> nodes.
            </summary>
            <param name="op">The operator.</param>
            <param name="left">The operand.</param>
            <param name="expression">The created <see cref="T:Loretta.Parsing.AST.UnaryOperationExpression" /></param>
            <returns><see langword="true" /></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParserBuilder.PostfixOperatorFactory(Loretta.Parsing.AST.Expression,GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.AST.Expression@)">
            <summary>
            The factory method for postfix <see cref="T:Loretta.Parsing.AST.UnaryOperationExpression" /> nodes.
            </summary>
            <param name="right">The operator.</param>
            <param name="op">The operand.</param>
            <param name="expression">The created <see cref="T:Loretta.Parsing.AST.UnaryOperationExpression" />.</param>
            <returns><see langword="true" /></returns>
        </member>
        <member name="M:Loretta.Parsing.LuaParserBuilder.AddBinaryOperator(System.Int32,System.Boolean,System.String)">
            <summary>
            Adds a binary operator to this builder.
            </summary>
            <param name="precedence">The operator's precedence.</param>
            <param name="isRightAssociative">Whether the operator is right-associative.</param>
            <param name="op">The operator token id.</param>
        </member>
        <member name="M:Loretta.Parsing.LuaParserBuilder.AddPrefixOperator(System.Int32,System.String)">
            <summary>
            Adds a prefix unary operator to this builder.
            </summary>
            <param name="precedence">The operator's precedence.</param>
            <param name="op">The operator token id.</param>
        </member>
        <member name="M:Loretta.Parsing.LuaParserBuilder.AddPostfixOperator(System.Int32,System.String)">
            <summary>
            Adds a postfix unary operator to this builder.
            </summary>
            <param name="precedence">The operator's precedence.</param>
            <param name="op">The operator token id.</param>
        </member>
        <member name="M:Loretta.Parsing.LuaParserBuilder.CreateParser(GParse.Lexing.ITokenReader{Loretta.Lexing.LuaTokenType},System.IProgress{GParse.Diagnostic})">
            <summary>
            Creates a <see cref="T:Loretta.Parsing.LuaParser" /> from the provided reader and diagnostic emitter.
            </summary>
            <param name="reader">The token reader to use.</param>
            <param name="diagnosticEmmiter">The diagnostic emitter.</param>
            <returns></returns>
        </member>
        <member name="T:Loretta.Parsing.Modules.AnonymousFunctionExpressionParserModule">
            <summary>
            The module that parses anonymous function expressions.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.Modules.AnonymousFunctionExpressionParserModule.Instance">
            <summary>
            The module's instance.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Modules.AnonymousFunctionExpressionParserModule.Register(GParse.Parsing.IPrattParserBuilder{Loretta.Lexing.LuaTokenType,Loretta.Parsing.AST.Expression})">
            <summary>
            Registers the module in the parser builder.
            </summary>
            <param name="builder">The builder to register the module in.</param>
        </member>
        <member name="M:Loretta.Parsing.Modules.AnonymousFunctionExpressionParserModule.TryParse(GParse.Parsing.IPrattParser{Loretta.Lexing.LuaTokenType,Loretta.Parsing.AST.Expression},System.IProgress{GParse.Diagnostic},Loretta.Parsing.AST.Expression@)">
            <inheritdoc/>
        </member>
        <member name="T:Loretta.Parsing.Modules.ArrowFunctionExpression">
            <summary>
            The module that parses arrow function expressions. Unimplemented.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Modules.ArrowFunctionExpression.TryParse(GParse.Parsing.IPrattParser{Loretta.Lexing.LuaTokenType,Loretta.Parsing.AST.Expression},System.IProgress{GParse.Diagnostic},Loretta.Parsing.AST.Expression@)">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.Modules.FunctionCallExpressionParserModule">
            <summary>
            The module that parses function call expressions.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Modules.FunctionCallExpressionParserModule.Register(GParse.Parsing.IPrattParserBuilder{Loretta.Lexing.LuaTokenType,Loretta.Parsing.AST.Expression},System.Int32)">
            <summary>
            Registers the module in a parser builder with the provided precedence.
            </summary>
            <param name="builder">The builder to register the module in.</param>
            <param name="precedence">The precedence to register with.</param>
        </member>
        <member name="P:Loretta.Parsing.Modules.FunctionCallExpressionParserModule.Precedence">
            <summary>
            The configured function call precedence.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Modules.FunctionCallExpressionParserModule.#ctor(System.Int32)">
            <summary>
            Initializes a new function call expression parser module.
            </summary>
            <param name="precedence">The precedence to be used as the function call precedence.</param>
        </member>
        <member name="M:Loretta.Parsing.Modules.FunctionCallExpressionParserModule.TryParse(GParse.Parsing.IPrattParser{Loretta.Lexing.LuaTokenType,Loretta.Parsing.AST.Expression},Loretta.Parsing.AST.Expression,System.IProgress{GParse.Diagnostic},Loretta.Parsing.AST.Expression@)">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.Modules.GroupedExpressionParserModule">
            <summary>
            The module that parses grouped expressions.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.Modules.GroupedExpressionParserModule.Instance">
            <summary>
            The module's instance.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Modules.GroupedExpressionParserModule.Register(GParse.Parsing.IPrattParserBuilder{Loretta.Lexing.LuaTokenType,Loretta.Parsing.AST.Expression})">
            <summary>
            Registers the module in a parser builder.
            </summary>
            <param name="builder">The builder to register in.</param>
        </member>
        <member name="M:Loretta.Parsing.Modules.GroupedExpressionParserModule.TryParse(GParse.Parsing.IPrattParser{Loretta.Lexing.LuaTokenType,Loretta.Parsing.AST.Expression},System.IProgress{GParse.Diagnostic},Loretta.Parsing.AST.Expression@)">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.Modules.IdentifierParserModule">
            <summary>
            The module that parses identifiers.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.Modules.IdentifierParserModule.Instance">
            <summary>
            The module's instance.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Modules.IdentifierParserModule.Register(GParse.Parsing.IPrattParserBuilder{Loretta.Lexing.LuaTokenType,Loretta.Parsing.AST.Expression})">
            <summary>
            Registers the module in a parser builder.
            </summary>
            <param name="builder">The builder to register in.</param>
        </member>
        <member name="M:Loretta.Parsing.Modules.IdentifierParserModule.TryParse(GParse.Parsing.IPrattParser{Loretta.Lexing.LuaTokenType,Loretta.Parsing.AST.Expression},System.IProgress{GParse.Diagnostic},Loretta.Parsing.AST.Expression@)">
            <inheritdoc/>
        </member>
        <member name="T:Loretta.Parsing.Modules.IndexExpressionParserModule">
            <summary>
            The module that parses indexing expressions.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Modules.IndexExpressionParserModule.Register(GParse.Parsing.IPrattParserBuilder{Loretta.Lexing.LuaTokenType,Loretta.Parsing.AST.Expression},System.Int32)">
            <summary>
            Registers the module in a parser builder.
            </summary>
            <param name="builder">The builder to register in.</param>
            <param name="precedence">The precedence to register the module with.</param>
        </member>
        <member name="P:Loretta.Parsing.Modules.IndexExpressionParserModule.Precedence">
            <summary>
            The precedence to use for the indexing operation.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Modules.IndexExpressionParserModule.#ctor(System.Int32)">
            <summary>
            Initializes a new indexing expression parser module.
            </summary>
            <param name="precedence"></param>
        </member>
        <member name="M:Loretta.Parsing.Modules.IndexExpressionParserModule.TryParse(GParse.Parsing.IPrattParser{Loretta.Lexing.LuaTokenType,Loretta.Parsing.AST.Expression},Loretta.Parsing.AST.Expression,System.IProgress{GParse.Diagnostic},Loretta.Parsing.AST.Expression@)">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.Modules.TableConstructorExpressionParserModule">
            <summary>
            The module that parses table constructor literal expressions.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.Modules.TableConstructorExpressionParserModule.Instance">
            <summary>
            The module's instance.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Modules.TableConstructorExpressionParserModule.Register(GParse.Parsing.IPrattParserBuilder{Loretta.Lexing.LuaTokenType,Loretta.Parsing.AST.Expression})">
            <summary>
            Registers the module in a parser builder.
            </summary>
            <param name="builder">The builder to register in.</param>
        </member>
        <member name="F:Loretta.Parsing.Modules.TableConstructorExpressionParserModule.FieldSeps">
            <summary>
            The two possible field separators.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Modules.TableConstructorExpressionParserModule.TryParse(GParse.Parsing.IPrattParser{Loretta.Lexing.LuaTokenType,Loretta.Parsing.AST.Expression},System.IProgress{GParse.Diagnostic},Loretta.Parsing.AST.Expression@)">
            <inheritdoc />
        </member>
        <member name="T:Loretta.Parsing.Scope">
            <summary>
            Represents a scope.
            </summary>
        </member>
        <member name="T:Loretta.Parsing.Scope.FindMode">
            <summary>
            The variable search mode.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.Scope.FindMode.DontCheck">
            <summary>
            Don't check any scopes, always create a new variable.
            Only supported for variables.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.Scope.FindMode.CheckSelf">
            <summary>
            Only checks the current scope.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.Scope.FindMode.CheckFunctionScope">
            <summary>
            Checks parents until we hit a function scope.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.Scope.FindMode.CheckParents">
            <summary>
            Checks all parents.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.Scope.Parent">
            <summary>
            The parent scope.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.Scope._variables">
            <summary>
            The variables registered in this scope.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.Scope._gotoLabels">
            <summary>
            The goto labels registered in this scope.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.Scope.Variables">
            <inheritdoc cref="F:Loretta.Parsing.Scope._variables" />
        </member>
        <member name="P:Loretta.Parsing.Scope.GotoLabels">
            <inheritdoc cref="F:Loretta.Parsing.Scope._gotoLabels" />
        </member>
        <member name="P:Loretta.Parsing.Scope.IsFunctionScope">
            <summary>
            Whether this scope is a function's.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Scope.#ctor(System.Boolean)">
            <summary>
            Initializes a new scope.
            </summary>
            <param name="isFunctionScope"><see cref="P:Loretta.Parsing.Scope.IsFunctionScope" /></param>
        </member>
        <member name="M:Loretta.Parsing.Scope.#ctor(Loretta.Parsing.Scope,System.Boolean)">
            <summary>
            Initializes a new scope.
            </summary>
            <param name="parent"><see cref="P:Loretta.Parsing.Scope.Parent" /></param>
            <param name="isFunctionScope"><see cref="P:Loretta.Parsing.Scope.IsFunctionScope" /></param>
        </member>
        <member name="M:Loretta.Parsing.Scope.TryFindVariable(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.Scope.FindMode,Loretta.Parsing.Variable@)">
            <summary>
            Attempts to find a variable.
            </summary>
            <param name="identifier">The identifier token.</param>
            <param name="findMode">The variable search mode.</param>
            <param name="variable">The variable found (if any).</param>
            <returns>Whether the variable was found.</returns>
        </member>
        <member name="M:Loretta.Parsing.Scope.TryFindVariable(System.String,Loretta.Parsing.Scope.FindMode,Loretta.Parsing.Variable@)">
            <inheritdoc cref="M:Loretta.Parsing.Scope.TryFindVariable(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.Scope.FindMode,Loretta.Parsing.Variable@)" />
        </member>
        <member name="M:Loretta.Parsing.Scope.GetVariable(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.Scope.FindMode)">
            <summary>
            Finds or creates the variable with the provided name.
            </summary>
            <param name="identifier">The identifier containing the name.</param>
            <param name="findMode">The search mode.</param>
            <returns>The found or created variable.</returns>
        </member>
        <member name="M:Loretta.Parsing.Scope.GetVariable(System.String,Loretta.Parsing.Scope.FindMode)">
            <inheritdoc cref="M:Loretta.Parsing.Scope.GetVariable(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.Scope.FindMode)" />
        </member>
        <member name="M:Loretta.Parsing.Scope.FindLabel(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.Scope.FindMode)">
            <summary>
            Attempts to find a goto label. Returns null if none is found.
            </summary>
            <param name="labelIdentifier">The label's identifier.</param>
            <param name="findMode">The label search mode.</param>
            <returns>The label or null if not found.</returns>
        </member>
        <member name="M:Loretta.Parsing.Scope.FindLabel(System.String,Loretta.Parsing.Scope.FindMode)">
            <inheritdoc cref="M:Loretta.Parsing.Scope.FindLabel(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.Scope.FindMode)" />
        </member>
        <member name="M:Loretta.Parsing.Scope.TryFindLabel(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.Scope.FindMode,Loretta.Parsing.GotoLabel@)">
            <summary>
            Attempts to find a goto label with the provided identifier.
            </summary>
            <param name="labelIdentifier">The label's identifier.</param>
            <param name="findMode">The label search mode.</param>
            <param name="label">The label, if found.</param>
            <returns>Whether the label was found.</returns>
        </member>
        <member name="M:Loretta.Parsing.Scope.TryFindLabel(System.String,Loretta.Parsing.Scope.FindMode,Loretta.Parsing.GotoLabel@)">
            <inheritdoc cref="M:Loretta.Parsing.Scope.TryFindLabel(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.Scope.FindMode,Loretta.Parsing.GotoLabel@)" />
        </member>
        <member name="M:Loretta.Parsing.Scope.GetLabel(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.Scope.FindMode)">
            <summary>
            Finds or creates a label.
            </summary>
            <param name="labelIdentifier">The label's identifier.</param>
            <param name="findMode">The label search mode.</param>
            <returns>The found or created label.</returns>
        </member>
        <member name="M:Loretta.Parsing.Scope.GetLabel(System.String,Loretta.Parsing.Scope.FindMode)">
            <inheritdoc cref="M:Loretta.Parsing.Scope.GetLabel(GParse.Lexing.Token{Loretta.Lexing.LuaTokenType},Loretta.Parsing.Scope.FindMode)" />
        </member>
        <member name="T:Loretta.Parsing.Variable">
            <summary>
            Represents a variable.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.Variable._G">
            <summary>
            The global table variable.
            </summary>
        </member>
        <member name="P:Loretta.Parsing.Variable.Identifier">
            <summary>
            The variable's identifier.
            </summary>
        </member>
        <member name="F:Loretta.Parsing.Variable.ParentScope">
            <summary>
            The variable's containing scope.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Variable.#ctor(System.String,Loretta.Parsing.Scope)">
            <summary>
            Initializes a new variable.
            </summary>
            <param name="name"><inheritdoc cref="P:Loretta.Parsing.Variable.Identifier" /></param>
            <param name="scope"><inheritdoc cref="F:Loretta.Parsing.Variable.ParentScope" /></param>
        </member>
        <member name="M:Loretta.Parsing.Variable.Rename(System.String)">
            <summary>
            Renames this variable.
            </summary>
            <param name="newIdentifier">The new identifier to be used by this variable.</param>
        </member>
        <member name="T:Loretta.Parsing.Visitor.ConstantFolder">
            <summary>
            A folder that does constant folding (evaluates expressions with constant values to their results).
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ConstantFolder.VisitUnaryOperation(Loretta.Parsing.AST.UnaryOperationExpression)">
            <summary>
            Folds unary operations.
            </summary>
            <param name="node">The unary operation to fold.</param>
            <returns>The folded node or the node with its operand folded.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ConstantFolder.VisitBinaryOperation(Loretta.Parsing.AST.BinaryOperationExpression)">
            <summary>
            Folds binary operations.
            </summary>
            <param name="node">The binary operation to fold.</param>
            <returns>The folded node or the node with its operands folded.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ConstantFolder.GetGroupedExpressionInnerExpression(Loretta.Parsing.AST.Expression)">
            <summary>
            Recursively fetches the innermost expression in a grouped expression of a {grouped
            expression | non-grouped expression}.
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ConstantFolder.IsFalsey(Loretta.Parsing.AST.Expression)">
            <summary>
            Checks whether the value is false according to lua's rules.
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ConstantFolder.CanConvertToBoolean(Loretta.Parsing.AST.Expression)">
            <summary>
            Checks whether we can statically convert this to a boolean (function calls, indexing
            operations and identifiers can't be converted since we don't know the values they might return)
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ConstantFolder.TryGetDictionaryFromTable(Loretta.Parsing.AST.TableConstructorExpression,System.Collections.Immutable.IImmutableDictionary{System.Object,Loretta.Parsing.AST.Expression}@)">
            <summary>
            Attempts to build a dictionary with all table indexes and values. The dictionary can
            only be built if all table keys are identifiers, constants or sequential.
            </summary>
            <param name="tableConstructor"></param>
            <param name="dictionary"></param>
            <returns></returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ConstantFolder.TryGetTableLength(Loretta.Parsing.AST.TableConstructorExpression,System.Int32@)">
            <summary>
            Attempts to get the table length. The length can only be obtained statically if all
            table keys are constants, identifiers or sequential.
            </summary>
            <param name="tableConstructor"></param>
            <param name="sequentialKeysCount"></param>
            <returns></returns>
        </member>
        <member name="T:Loretta.Parsing.Visitor.ITreeVisitor">
            <summary>
            An interface for classes that implement the visitor pattern.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitNil(Loretta.Parsing.AST.NilExpression)">
            <summary>
            Visits a nil literal expression.
            </summary>
            <param name="node">The nil expression to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitBoolean(Loretta.Parsing.AST.BooleanExpression)">
            <summary>
            Visits a boolean literal expression.
            </summary>
            <param name="node">The boolean literal expression to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitIdentifier(Loretta.Parsing.AST.IdentifierExpression)">
            <summary>
            Visits an identifier expression.
            </summary>
            <param name="node">The identifier expression to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitIndex(Loretta.Parsing.AST.IndexExpression)">
            <summary>
            Visits an indexing operation expression.
            </summary>
            <param name="node">The indexing operation to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitNumber(Loretta.Parsing.AST.NumberExpression)">
            <summary>
            Visits a number literal expression.
            </summary>
            <param name="node">The number literal expression to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitString(Loretta.Parsing.AST.StringExpression)">
            <summary>
            Visits a string literal expression.
            </summary>
            <param name="node">The string literal expression to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitVarArg(Loretta.Parsing.AST.VarArgExpression)">
            <summary>
            Visits a vararg expression.
            </summary>
            <param name="node">The vararg expression to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitFunctionCall(Loretta.Parsing.AST.FunctionCallExpression)">
            <summary>
            Visits a function call expression.
            </summary>
            <param name="node">The function call expression.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitUnaryOperation(Loretta.Parsing.AST.UnaryOperationExpression)">
            <summary>
            Visits an unary operation expression.
            </summary>
            <param name="node">The unary operation expression to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitGroupedExpression(Loretta.Parsing.AST.GroupedExpression)">
            <summary>
            Visits a grouped expression.
            </summary>
            <param name="node">The grouped expression to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitBinaryOperation(Loretta.Parsing.AST.BinaryOperationExpression)">
            <summary>
            Visits a binary operation expression.
            </summary>
            <param name="node">The binary operation expression to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitTableField(Loretta.Parsing.AST.Tables.TableField)">
            <summary>
            Visits a table field.
            </summary>
            <param name="node">The table field to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitTableConstructor(Loretta.Parsing.AST.TableConstructorExpression)">
            <summary>
            Visits a table constructor expression.
            </summary>
            <param name="node">The table constructor expression to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitAnonymousFunction(Loretta.Parsing.AST.AnonymousFunctionExpression)">
            <summary>
            Visits an anonymous function expression.
            </summary>
            <param name="node">The anonymous function expression to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitAssignment(Loretta.Parsing.AST.AssignmentStatement)">
            <summary>
            Visits an assignment statement.
            </summary>
            <param name="node">The assignment statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitCompoundAssignmentStatement(Loretta.Parsing.AST.CompoundAssignmentStatement)">
            <summary>
            Visits a compound assignment statement.
            </summary>
            <param name="compoundAssignmentStatement">The compound assignment statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitBreak(Loretta.Parsing.AST.BreakStatement)">
            <summary>
            Visits a break statement.
            </summary>
            <param name="node">The break statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitContinue(Loretta.Parsing.AST.ContinueStatement)">
            <summary>
            Visits a continue statement.
            </summary>
            <param name="node">The continue statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitDo(Loretta.Parsing.AST.DoStatement)">
            <summary>
            Visits a do statement.
            </summary>
            <param name="node">The do statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitExpressionStatement(Loretta.Parsing.AST.ExpressionStatement)">
            <summary>
            Visits an expression statement node.
            </summary>
            <param name="node">The expression statement node to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitFunctionDefinition(Loretta.Parsing.AST.FunctionDefinitionStatement)">
            <summary>
            Visits a function definition statement.
            </summary>
            <param name="node">The function definition statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitGotoLabel(Loretta.Parsing.AST.GotoLabelStatement)">
            <summary>
            Visits a goto label.
            </summary>
            <param name="node">The goto label to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitGoto(Loretta.Parsing.AST.GotoStatement)">
            <summary>
            Visits a goto statement.
            </summary>
            <param name="node">The goto statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitIfStatement(Loretta.Parsing.AST.IfStatement)">
            <summary>
            Visits an if statement.
            </summary>
            <param name="node">The if statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitGenericFor(Loretta.Parsing.AST.GenericForLoopStatement)">
            <summary>
            Visits a generic for loop statement.
            </summary>
            <param name="node">The generic for loop statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitLocalVariableDeclaration(Loretta.Parsing.AST.LocalVariableDeclarationStatement)">
            <summary>
            Visits a local variable declaration.
            </summary>
            <param name="node">The local variable declaration to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitNode(Loretta.Parsing.AST.LuaASTNode)">
            <summary>
            Visits an AST node.
            </summary>
            <param name="node">The AST node to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitNumericFor(Loretta.Parsing.AST.NumericForLoopStatement)">
            <summary>
            Visits a numeric for statement.
            </summary>
            <param name="node">The numeric for statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitRepeatUntil(Loretta.Parsing.AST.RepeatUntilStatement)">
            <summary>
            Visits a repeat until statement.
            </summary>
            <param name="node">The repeat until statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitReturn(Loretta.Parsing.AST.ReturnStatement)">
            <summary>
            Visits a return statement.
            </summary>
            <param name="node">The return statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitStatementList(Loretta.Parsing.AST.StatementList)">
            <summary>
            Visits a statement list.
            </summary>
            <param name="node">The statement list to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitWhileLoop(Loretta.Parsing.AST.WhileLoopStatement)">
            <summary>
            Visits a while loop statement.
            </summary>
            <param name="node">The while loop statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor.VisitEmptyStatement(Loretta.Parsing.AST.EmptyStatement)">
            <summary>
            Visits an empty statement.
            </summary>
            <param name="emptyStatement">The empty statement to visit.</param>
        </member>
        <member name="T:Loretta.Parsing.Visitor.ITreeVisitor`1">
            <summary>
            The interface for classes that implement the visitor pattern with a return value.
            </summary>
            <typeparam name="T">The value returned by the visitor methods.</typeparam>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitNil(Loretta.Parsing.AST.NilExpression)">
            <summary>
            Visits a nil literal expression.
            </summary>
            <param name="node">The nil expression to visit.</param>
            <returns>The result of visiting this nil literal expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitBoolean(Loretta.Parsing.AST.BooleanExpression)">
            <summary>
            Visits a boolean literal expression.
            </summary>
            <param name="node">The boolean literal expression to visit.</param>
            <returns>The result of visiting this boolean literal expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitIdentifier(Loretta.Parsing.AST.IdentifierExpression)">
            <summary>
            Visits an identifier expression.
            </summary>
            <param name="node">The identifier expression to visit.</param>
            <returns>The result of visiting this identifier expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitIndex(Loretta.Parsing.AST.IndexExpression)">
            <summary>
            Visits an indexing operation expression.
            </summary>
            <param name="node">The indexing operation expression to visit.</param>
            <returns>The result of visiting this indexing operation expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitNumber(Loretta.Parsing.AST.NumberExpression)">
            <summary>
            Visits a number literal expression.
            </summary>
            <param name="node">The number literal expression to visit.</param>
            <returns>The result of visiting this number literal expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitString(Loretta.Parsing.AST.StringExpression)">
            <summary>
            Visits a string literal expression.
            </summary>
            <param name="node">The string literal expression to visit.</param>
            <returns>The result of visiting this string literal expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitVarArg(Loretta.Parsing.AST.VarArgExpression)">
            <summary>
            Visits a vararg expression.
            </summary>
            <param name="node">The vararg expression to visit.</param>
            <returns>The result of visiting this vararg expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitFunctionCall(Loretta.Parsing.AST.FunctionCallExpression)">
            <summary>
            Visits a function call expression.
            </summary>
            <param name="node">The function call expression.</param>
            <returns>The result of visiting this function call expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitUnaryOperation(Loretta.Parsing.AST.UnaryOperationExpression)">
            <summary>
            Visits an unary operation expression.
            </summary>
            <param name="node">The unary operation expression to visit.</param>
            <returns>The result of visiting this unary operation expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitGroupedExpression(Loretta.Parsing.AST.GroupedExpression)">
            <summary>
            Visits a grouped expression.
            </summary>
            <param name="node">The grouped expression to visit.</param>
            <returns>The result of visiting this grouped expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitBinaryOperation(Loretta.Parsing.AST.BinaryOperationExpression)">
            <summary>
            Visits a binary operation expression.
            </summary>
            <param name="node">The binary operation expression to visit.</param>
            <returns>The result of visiting this binary operation expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitTableField(Loretta.Parsing.AST.Tables.TableField)">
            <summary>
            Visits a table field.
            </summary>
            <param name="node">The table field to visit.</param>
            <returns>The result of visiting this table field.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitTableConstructor(Loretta.Parsing.AST.TableConstructorExpression)">
            <summary>
            Visits a table constructor expression.
            </summary>
            <param name="node">The table constructor expression to visit.</param>
            <returns>The result of visiting this table constructor expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitAnonymousFunction(Loretta.Parsing.AST.AnonymousFunctionExpression)">
            <summary>
            Visits an anonymous function expression.
            </summary>
            <param name="node">The anonymous function expression to visit.</param>
            <returns>The result of visiting this anonymous function expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitAssignment(Loretta.Parsing.AST.AssignmentStatement)">
            <summary>
            Visits an assignment statement.
            </summary>
            <param name="node">The assignment statement to visit.</param>
            <returns>The result of visiting this assignment statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitCompoundAssignmentStatement(Loretta.Parsing.AST.CompoundAssignmentStatement)">
            <summary>
            Visits a compound assignment statement.
            </summary>
            <param name="compoundAssignmentStatement">The compound assignment statement to visit.</param>
            <returns>The result of visiting this compound assignment statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitBreak(Loretta.Parsing.AST.BreakStatement)">
            <summary>
            Visits a break statement.
            </summary>
            <param name="node">The break statement to visit.</param>
            <returns>The result of visiting this break statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitContinue(Loretta.Parsing.AST.ContinueStatement)">
            <summary>
            Visits a continue statement.
            </summary>
            <param name="node">The continue statement to visit.</param>
            <returns>The result of visiting this continue statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitDo(Loretta.Parsing.AST.DoStatement)">
            <summary>
            Visits a do statement.
            </summary>
            <param name="node">The do statement to visit.</param>
            <returns>The result of visiting this do statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitExpressionStatement(Loretta.Parsing.AST.ExpressionStatement)">
            <summary>
            Visits an expression statement node.
            </summary>
            <param name="node">The expression statement node to visit.</param>
            <returns>The result of visiting this expression statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitFunctionDefinition(Loretta.Parsing.AST.FunctionDefinitionStatement)">
            <summary>
            Visits a function definition statement.
            </summary>
            <param name="node">The function definition statement to visit.</param>
            <returns>The result of visiting this function definition statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitGotoLabel(Loretta.Parsing.AST.GotoLabelStatement)">
            <summary>
            Visits a goto label.
            </summary>
            <param name="node">The goto label to visit.</param>
            <returns>The result of visiting this goto label.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitGoto(Loretta.Parsing.AST.GotoStatement)">
            <summary>
            Visits a goto statement.
            </summary>
            <param name="node">The goto statement to visit.</param>
            <returns>The result of visiting this goto statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitIfStatement(Loretta.Parsing.AST.IfStatement)">
            <summary>
            Visits an if statement.
            </summary>
            <param name="node">The if statement to visit.</param>
            <returns>The result of visiting this if statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitGenericFor(Loretta.Parsing.AST.GenericForLoopStatement)">
            <summary>
            Visits a generic for loop statement.
            </summary>
            <param name="node">The generic for loop statement to visit.</param>
            <returns>The result of visiting this generic for loop statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitLocalVariableDeclaration(Loretta.Parsing.AST.LocalVariableDeclarationStatement)">
            <summary>
            Visits a local variable declaration.
            </summary>
            <param name="node">The local variable declaration to visit.</param>
            <returns>The result of visiting this local variable declaration statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitNode(Loretta.Parsing.AST.LuaASTNode)">
            <summary>
            Visits an AST node.
            </summary>
            <param name="node">The AST node to visit.</param>
            <returns>The result of visiting this AST node.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitNumericFor(Loretta.Parsing.AST.NumericForLoopStatement)">
            <summary>
            Visits a numeric for loop statement.
            </summary>
            <param name="node">The numeric for statement to visit.</param>
            <returns>The result of visiting this numeric for loop statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitRepeatUntil(Loretta.Parsing.AST.RepeatUntilStatement)">
            <summary>
            Visits a repeat until statement.
            </summary>
            <param name="node">The repeat until statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitReturn(Loretta.Parsing.AST.ReturnStatement)">
            <summary>
            Visits a return statement.
            </summary>
            <param name="node">The return statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitStatementList(Loretta.Parsing.AST.StatementList)">
            <summary>
            Visits a statement list.
            </summary>
            <param name="node">The statement list to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitWhileLoop(Loretta.Parsing.AST.WhileLoopStatement)">
            <summary>
            Visits a while loop statement.
            </summary>
            <param name="node">The while loop statement to visit.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.ITreeVisitor`1.VisitEmptyStatement(Loretta.Parsing.AST.EmptyStatement)">
            <summary>
            Visits an empty statement.
            </summary>
            <param name="emptyStatement">The empty statement to visit.</param>
        </member>
        <member name="T:Loretta.Parsing.Visitor.RawStringRewriter">
            <summary>
            A folder that rewrites the raw form of strings to only escape required (non-alphanumeric,
            non-punctuation and non-space) characters.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Visitor.RawStringRewriter.VisitString(Loretta.Parsing.AST.StringExpression)">
            <summary>
            Rewrites the raw form of the provided string.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="T:Loretta.Parsing.Visitor.TreeFolderBase">
            <summary>
            The base class for tree folders.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitNil(Loretta.Parsing.AST.NilExpression)">
            <summary>
            Folds a nil expression. Does nothing by default.
            </summary>
            <param name="node">The nil expression to fold.</param>
            <returns>The folded expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitBoolean(Loretta.Parsing.AST.BooleanExpression)">
            <summary>
            Folds a boolean expression. Does nothing by default.
            </summary>
            <param name="node">The boolean expression to fold.</param>
            <returns>The folded expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitIdentifier(Loretta.Parsing.AST.IdentifierExpression)">
            <summary>
            Folds an identifier expression. Does nothing by default.
            </summary>
            <param name="node">The identifier expression to fold.</param>
            <returns>The folded expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitNumber(Loretta.Parsing.AST.NumberExpression)">
            <summary>
            Folds a number expression. Does nothing by default.
            </summary>
            <param name="node">The number expression to fold.</param>
            <returns>The folded expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitString(Loretta.Parsing.AST.StringExpression)">
            <summary>
            Folds a string expression. Does nothing by default.
            </summary>
            <param name="node">The string expression to fold.</param>
            <returns>The folded expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitVarArg(Loretta.Parsing.AST.VarArgExpression)">
            <summary>
            Folds a vararg expression. Does nothing by default.
            </summary>
            <param name="node">The vararg expression to fold.</param>
            <returns>The folded expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitEmptyStatement(Loretta.Parsing.AST.EmptyStatement)">
            <summary>
            Folds an empty statement. Does nothing by default.
            </summary>
            <param name="node">The empty statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitIndex(Loretta.Parsing.AST.IndexExpression)">
            <summary>
            Folds an indexing operation expression. Folds the <see cref="P:Loretta.Parsing.AST.IndexExpression.Indexee" />
            and then the <see cref="P:Loretta.Parsing.AST.IndexExpression.Indexer" /> by default.
            </summary>
            <param name="node">The indexing operation expression to fold.</param>
            <returns>The folded expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitFunctionCall(Loretta.Parsing.AST.FunctionCallExpression)">
            <summary>
            Folds a function call expression. Folds the <see cref="P:Loretta.Parsing.AST.FunctionCallExpression.Function"
            /> and then the <see cref="P:Loretta.Parsing.AST.FunctionCallExpression.Arguments" /> in the collection's
            order by default.
            </summary>
            <param name="node">The function call expression to fold.</param>
            <returns>The folded expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitUnaryOperation(Loretta.Parsing.AST.UnaryOperationExpression)">
            <summary>
            Folds an unary operation expression. Folds the <see
            cref="P:Loretta.Parsing.AST.UnaryOperationExpression.Operand" /> by default.
            </summary>
            <param name="node">The unary operation expression to fold.</param>
            <returns>The folded expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitGroupedExpression(Loretta.Parsing.AST.GroupedExpression)">
            <summary>
            Folds a grouped expression. Folds the <see cref="P:Loretta.Parsing.AST.GroupedExpression.InnerExpression" />
            by default.
            </summary>
            <param name="node">The grouped expression to fold.</param>
            <returns>The folded expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitBinaryOperation(Loretta.Parsing.AST.BinaryOperationExpression)">
            <summary>
            Folds a binary operation expression. Folds the <see
            cref="P:Loretta.Parsing.AST.BinaryOperationExpression.Left" /> operand and then the <see
            cref="P:Loretta.Parsing.AST.BinaryOperationExpression.Right" /> operand by default.
            </summary>
            <param name="node">The binary operation expression to fold.</param>
            <returns>The folded expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitTableField(Loretta.Parsing.AST.Tables.TableField)">
            <summary>
            Folds a table field. Folds the field's <see cref="P:Loretta.Parsing.AST.Tables.TableField.Key" /> (if an expresion)
            and the field's <see cref="P:Loretta.Parsing.AST.Tables.TableField.Value" /> by default.
            </summary>
            <param name="node">The table field to fold.</param>
            <returns>The folded table field.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitTableConstructor(Loretta.Parsing.AST.TableConstructorExpression)">
            <summary>
            Folds a table constructor expression. Folds all <see
            cref="P:Loretta.Parsing.AST.TableConstructorExpression.Fields" /> in the collection's order by default.
            </summary>
            <param name="node">The table constructor expression to fold.</param>
            <returns>The folded expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitAnonymousFunction(Loretta.Parsing.AST.AnonymousFunctionExpression)">
            <summary>
            Folds an anonymous function expression. Folds the <see
            cref="P:Loretta.Parsing.AST.AnonymousFunctionExpression.Body" /> by default.
            </summary>
            <param name="node">The anonymous function expression to fold.</param>
            <returns>The folded expression.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitAssignment(Loretta.Parsing.AST.AssignmentStatement)">
            <summary>
            Folds an assignment statement. Folds the <see cref="P:Loretta.Parsing.AST.AssignmentStatement.Variables" /> in
            the collection's order and then the <see cref="P:Loretta.Parsing.AST.AssignmentStatement.Values" /> in the
            collection's order by default.
            </summary>
            <param name="node">The assignment statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitCompoundAssignmentStatement(Loretta.Parsing.AST.CompoundAssignmentStatement)">
            <summary>
            Folds a compound assignment statement. Folds the <see
            cref="P:Loretta.Parsing.AST.CompoundAssignmentStatement.Assignee" /> and then the <see
            cref="P:Loretta.Parsing.AST.CompoundAssignmentStatement.ValueExpression" /> by default.
            </summary>
            <param name="node">The compound assignment statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitBreak(Loretta.Parsing.AST.BreakStatement)">
            <summary>
            Folds a break statement. Does nothing by default.
            </summary>
            <param name="node">The break statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitContinue(Loretta.Parsing.AST.ContinueStatement)">
            <summary>
            Folds a continue statement. Does nothing by default.
            </summary>
            <param name="node">The continue statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitDo(Loretta.Parsing.AST.DoStatement)">
            <summary>
            Folds a do statement. Folds the do's <see cref="P:Loretta.Parsing.AST.DoStatement.Body" /> by default.
            </summary>
            <param name="node">The do statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitExpressionStatement(Loretta.Parsing.AST.ExpressionStatement)">
            <summary>
            Folds an expression statement. Folds the <see cref="P:Loretta.Parsing.AST.ExpressionStatement.Expression" />
            by default.
            </summary>
            <param name="node">The expression statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitFunctionDefinition(Loretta.Parsing.AST.FunctionDefinitionStatement)">
            <summary>
            Folds a function definition statement. Folds the function's <see
            cref="P:Loretta.Parsing.AST.FunctionDefinitionStatement.Name" /> (if not local) and then the function's <see
            cref="P:Loretta.Parsing.AST.FunctionDefinitionStatement.Body" /> by default. and the function's body by default.
            </summary>
            <param name="node">The function definition statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitGotoLabel(Loretta.Parsing.AST.GotoLabelStatement)">
            <summary>
            Folds a goto label. Does nothing by default.
            </summary>
            <param name="node">The goto label to fold.</param>
            <returns>The folded label.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitGoto(Loretta.Parsing.AST.GotoStatement)">
            <summary>
            Folds a goto statement. Does nothing by default.
            </summary>
            <param name="node">The goto statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitIfStatement(Loretta.Parsing.AST.IfStatement)">
            <summary>
            Folds an if statement. Folds the if <see cref="P:Loretta.Parsing.AST.IfStatement.Clauses" />' <see
            cref="P:Loretta.Parsing.AST.IfClause.Condition" /> and <see cref="P:Loretta.Parsing.AST.IfClause.Body" /> and the <see
            cref="P:Loretta.Parsing.AST.IfStatement.ElseBlock" /> (if any) by default.
            </summary>
            <param name="node">The if statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitGenericFor(Loretta.Parsing.AST.GenericForLoopStatement)">
            <summary>
            Folds a generic for statement. Folds the <see cref="P:Loretta.Parsing.AST.GenericForLoopStatement.Expressions"
            />'s in the collection's order and the <see cref="P:Loretta.Parsing.AST.GenericForLoopStatement.Body" /> by default.
            </summary>
            <param name="node">The generic for statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitLocalVariableDeclaration(Loretta.Parsing.AST.LocalVariableDeclarationStatement)">
            <summary>
            Folds a local variable declaration statement. Folds the <see
            cref="P:Loretta.Parsing.AST.LocalVariableDeclarationStatement.Values" /> in the collection's order by default.
            </summary>
            <param name="node">The local variable declaration statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitNode(Loretta.Parsing.AST.LuaASTNode)">
            <summary>
            Folds a node.
            </summary>
            <param name="node">The node to fold.</param>
            <returns>The folded node.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitNumericFor(Loretta.Parsing.AST.NumericForLoopStatement)">
            <summary>
            Folds a numeric for statement. Folds the <see cref="P:Loretta.Parsing.AST.NumericForLoopStatement.Body" />
            then the <see cref="P:Loretta.Parsing.AST.NumericForLoopStatement.Initial" /> value then the <see
            cref="P:Loretta.Parsing.AST.NumericForLoopStatement.Final" /> value and then the <see
            cref="P:Loretta.Parsing.AST.NumericForLoopStatement.Step" /> (if
            any) by default.
            </summary>
            <param name="node">The numeric for statement statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitRepeatUntil(Loretta.Parsing.AST.RepeatUntilStatement)">
            <summary>
            Folds a repeat until statement. Folds the <see cref="P:Loretta.Parsing.AST.RepeatUntilStatement.Body" /> and
            the <see cref="P:Loretta.Parsing.AST.RepeatUntilStatement.Condition" /> by default.
            </summary>
            <param name="node">The repeat until statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitReturn(Loretta.Parsing.AST.ReturnStatement)">
            <summary>
            Folds a return statement. Folds the <see cref="P:Loretta.Parsing.AST.ReturnStatement.Values" /> in the
            collection's order by default.
            </summary>
            <param name="node">The return statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitStatementList(Loretta.Parsing.AST.StatementList)">
            <summary>
            Folds a statement list. Folds the <see cref="F:Loretta.Parsing.AST.StatementList.Body" />'s statements in the
            collection's order by default.
            </summary>
            <param name="node">The statement list to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeFolderBase.VisitWhileLoop(Loretta.Parsing.AST.WhileLoopStatement)">
            <summary>
            Folds a while loop statement. Folds the <see cref="P:Loretta.Parsing.AST.WhileLoopStatement.Condition" /> and
            then the <see cref="P:Loretta.Parsing.AST.WhileLoopStatement.Body" /> by default.
            </summary>
            <param name="node">The while loop statement to fold.</param>
            <returns>The folded statement.</returns>
        </member>
        <member name="T:Loretta.Parsing.Visitor.TreeWalkerBase">
            <summary>
            The base class for tree walkers.
            </summary>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitNil(Loretta.Parsing.AST.NilExpression)">
            <summary>
            Walks into a nil expression. Does nothing by default.
            </summary>
            <param name="node">The nil expression to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitBoolean(Loretta.Parsing.AST.BooleanExpression)">
            <summary>
            Walks into a boolean expression. Does nothing by default.
            </summary>
            <param name="node">The boolean expression to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitIdentifier(Loretta.Parsing.AST.IdentifierExpression)">
            <summary>
            Walks into an identifier expression. Does nothing by default.
            </summary>
            <param name="node">The identifier expression to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitIndex(Loretta.Parsing.AST.IndexExpression)">
            <summary>
            Walks into an indexing operation expression. Walks into the <see
            cref="P:Loretta.Parsing.AST.IndexExpression.Indexee" /> and then into the <see cref="P:Loretta.Parsing.AST.IndexExpression.Indexer"
            /> by default.
            </summary>
            <param name="node">The indexing operation expression to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitNumber(Loretta.Parsing.AST.NumberExpression)">
            <summary>
            Walks into a number expression. Does nothing by default.
            </summary>
            <param name="node">The number expression to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitString(Loretta.Parsing.AST.StringExpression)">
            <summary>
            Walks into a string expression. Does nothing by default.
            </summary>
            <param name="node">The string expression to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitVarArg(Loretta.Parsing.AST.VarArgExpression)">
            <summary>
            Walks into a vararg expression. Does nothing by default.
            </summary>
            <param name="node">The vararg expression to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitFunctionCall(Loretta.Parsing.AST.FunctionCallExpression)">
            <summary>
            Walks into a function call expression. Walks into the <see
            cref="P:Loretta.Parsing.AST.FunctionCallExpression.Function" /> being called then the <see
            cref="P:Loretta.Parsing.AST.FunctionCallExpression.Arguments" /> in the collection's order by default.
            </summary>
            <param name="node">The function call expression to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitUnaryOperation(Loretta.Parsing.AST.UnaryOperationExpression)">
            <summary>
            Walks into a unary operation expression. Walks into the <see
            cref="P:Loretta.Parsing.AST.UnaryOperationExpression.Operand" /> by default.
            </summary>
            <param name="node">The unuary operation expression to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitGroupedExpression(Loretta.Parsing.AST.GroupedExpression)">
            <summary>
            Walks into a grouped expression. Walks into the <see
            cref="P:Loretta.Parsing.AST.GroupedExpression.InnerExpression" /> by default.
            </summary>
            <param name="node">The grouped expression to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitBinaryOperation(Loretta.Parsing.AST.BinaryOperationExpression)">
            <summary>
            Walks into a binary operation expression. Walks into the <see
            cref="P:Loretta.Parsing.AST.BinaryOperationExpression.Left" /> operand then into the <see
            cref="P:Loretta.Parsing.AST.BinaryOperationExpression.Right" /> operand by default.
            </summary>
            <param name="node">The nil expression to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitTableField(Loretta.Parsing.AST.Tables.TableField)">
            <summary>
            Walks into a table field. Walks into the <see cref="P:Loretta.Parsing.AST.Tables.TableField.Key" /> (if any) then
            into the <see cref="P:Loretta.Parsing.AST.Tables.TableField.Value" /> by default.
            </summary>
            <param name="node">The table field to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitTableConstructor(Loretta.Parsing.AST.TableConstructorExpression)">
            <summary>
            Walks into a table constructor expression. Walks into the table <see
            cref="P:Loretta.Parsing.AST.TableConstructorExpression.Fields" /> in the order of the collection by default.
            </summary>
            <param name="node">The table constructor expression to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitAnonymousFunction(Loretta.Parsing.AST.AnonymousFunctionExpression)">
            <summary>
            Walks into an anonymous function expression. Walks into the <see
            cref="P:Loretta.Parsing.AST.AnonymousFunctionExpression.Arguments" /> in the order of the collection and then
            into the <see cref="P:Loretta.Parsing.AST.AnonymousFunctionExpression.Body" /> by default.
            </summary>
            <param name="node">The anonymous function expression to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitAssignment(Loretta.Parsing.AST.AssignmentStatement)">
            <summary>
            Walks into an assignment statement. Walks into the <see
            cref="P:Loretta.Parsing.AST.AssignmentStatement.Variables" /> in the order of the collection and then into the
            <see cref="P:Loretta.Parsing.AST.AssignmentStatement.Values" /> in the order of the collection by default.
            </summary>
            <param name="node">The assignment statement to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitCompoundAssignmentStatement(Loretta.Parsing.AST.CompoundAssignmentStatement)">
            <summary>
            Walks into a compound assignment statement. Walks into the <see
            cref="P:Loretta.Parsing.AST.CompoundAssignmentStatement.Assignee" /> and then into the <see
            cref="P:Loretta.Parsing.AST.CompoundAssignmentStatement.ValueExpression" /> by default.
            </summary>
            <param name="node">The compound assignment statement to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitBreak(Loretta.Parsing.AST.BreakStatement)">
            <summary>
            Walks into a break statement. Does nothing by default.
            </summary>
            <param name="node">The break statement to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitContinue(Loretta.Parsing.AST.ContinueStatement)">
            <summary>
            Walks into a continue statement. Does nothing by default.
            </summary>
            <param name="node">The continue statement to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitDo(Loretta.Parsing.AST.DoStatement)">
            <summary>
            Walks into a do statement. Walks into the <see cref="P:Loretta.Parsing.AST.DoStatement.Body" /> by default.
            </summary>
            <param name="node">The do statement to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitExpressionStatement(Loretta.Parsing.AST.ExpressionStatement)">
            <summary>
            Walks into an expression statement. Visits the <see
            cref="P:Loretta.Parsing.AST.ExpressionStatement.Expression" /> by default.
            </summary>
            <param name="node">The expression statement to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitFunctionDefinition(Loretta.Parsing.AST.FunctionDefinitionStatement)">
            <summary>
            Walks into a function definition statement. Walks into the <see
            cref="P:Loretta.Parsing.AST.FunctionDefinitionStatement.Name" /> then into the function <see
            cref="P:Loretta.Parsing.AST.FunctionDefinitionStatement.Arguments" /> in the collection's order and then into
            the <see cref="P:Loretta.Parsing.AST.FunctionDefinitionStatement.Body" /> by default.
            </summary>
            <param name="node">The break statement to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitGotoLabel(Loretta.Parsing.AST.GotoLabelStatement)">
            <summary>
            Walks into a goto label. Does nothing by default.
            </summary>
            <param name="node">The goto label to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitGoto(Loretta.Parsing.AST.GotoStatement)">
            <summary>
            Walks into a goto statement. Does nothing by default.
            </summary>
            <param name="node">The goto statement to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitIfStatement(Loretta.Parsing.AST.IfStatement)">
            <summary>
            Walks into an if statement. Walks into each <see cref="P:Loretta.Parsing.AST.IfStatement.Clauses" />' <see
            cref="P:Loretta.Parsing.AST.IfClause.Condition" /> and <see cref="P:Loretta.Parsing.AST.IfClause.Body" /> in the collection's order
            and then into the <see cref="P:Loretta.Parsing.AST.IfStatement.ElseBlock" /> if any by default.
            </summary>
            <param name="node">The if statement to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitGenericFor(Loretta.Parsing.AST.GenericForLoopStatement)">
            <summary>
            Walks into a generic for statement. Walks into the <see
            cref="P:Loretta.Parsing.AST.GenericForLoopStatement.Variables" /> in the collection's order and then into the
            <see cref="P:Loretta.Parsing.AST.GenericForLoopStatement.Expressions" /> in the collection's order and then
            into the <see cref="P:Loretta.Parsing.AST.GenericForLoopStatement.Body" /> by default.
            </summary>
            <param name="node">The generic for statement to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitLocalVariableDeclaration(Loretta.Parsing.AST.LocalVariableDeclarationStatement)">
            <summary>
            Walks into a local variable declaration statement. Walks into the <see
            cref="P:Loretta.Parsing.AST.LocalVariableDeclarationStatement.Identifiers" /> in the collection's order and
            then into the <see cref="P:Loretta.Parsing.AST.LocalVariableDeclarationStatement.Values" /> in the
            collection's order by default.
            </summary>
            <param name="node">The local variable declaration statement to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitNode(Loretta.Parsing.AST.LuaASTNode)">
            <summary>
            Walks into a node.
            </summary>
            <param name="node">The node to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitNumericFor(Loretta.Parsing.AST.NumericForLoopStatement)">
            <summary>
            Walks into a numeric for loop statement. Walks into the <see
            cref="P:Loretta.Parsing.AST.NumericForLoopStatement.Variable" /> then into <see
            cref="P:Loretta.Parsing.AST.NumericForLoopStatement.Initial" /> then into <see
            cref="P:Loretta.Parsing.AST.NumericForLoopStatement.Final" /> then into the <see
            cref="P:Loretta.Parsing.AST.NumericForLoopStatement.Step" /> (if any) and then into the <see
            cref="P:Loretta.Parsing.AST.NumericForLoopStatement.Body" />.
            </summary>
            <param name="node">The numeric for loop statement to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitRepeatUntil(Loretta.Parsing.AST.RepeatUntilStatement)">
            <summary>
            Walks into a repeat until statement. Walks into the <see
            cref="P:Loretta.Parsing.AST.RepeatUntilStatement.Body" /> and then into the <see
            cref="P:Loretta.Parsing.AST.RepeatUntilStatement.Condition" /> by default.
            </summary>
            <param name="node">The repeat until statement to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitReturn(Loretta.Parsing.AST.ReturnStatement)">
            <summary>
            Walks into a return statement. Walks into the <see cref="P:Loretta.Parsing.AST.ReturnStatement.Values" /> in
            the collection's order by default.
            </summary>
            <param name="node">The repeat until statement to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitStatementList(Loretta.Parsing.AST.StatementList)">
            <summary>
            Walks into a statement list. Walks into the <see cref="F:Loretta.Parsing.AST.StatementList.Body" />'s
            statements in the collection's order by default.
            </summary>
            <param name="node">The statement list to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitWhileLoop(Loretta.Parsing.AST.WhileLoopStatement)">
            <summary>
            Walks into a while loop statement. Walks into the <see
            cref="P:Loretta.Parsing.AST.WhileLoopStatement.Condition" /> then into the <see cref="P:Loretta.Parsing.AST.WhileLoopStatement.Body"
            /> by default.
            </summary>
            <param name="node">The while loop statement to walk into.</param>
        </member>
        <member name="M:Loretta.Parsing.Visitor.TreeWalkerBase.VisitEmptyStatement(Loretta.Parsing.AST.EmptyStatement)">
            <summary>
            Walks into an empty statement. Does nothing by default.
            </summary>
            <param name="emptyStatement">The empty statement to walk into.</param>
        </member>
        <member name="T:Loretta.Utilities.CharUtils">
            <summary>
            A general character utility class.
            </summary>
        </member>
        <member name="M:Loretta.Utilities.CharUtils.IsInRange(System.Char,System.Char,System.Char)">
            <summary>
            Checks whether the provided <paramref name="value" /> is in the range [ <paramref
            name="start" />, <paramref name="end" />].
            </summary>
            <param name="start">The first character of the range (inclusive).</param>
            <param name="value">The character to check for.</param>
            <param name="end">The last character of the range (inclusive).</param>
            <returns>Whether the provided character is in the range.</returns>
        </member>
        <member name="M:Loretta.Utilities.CharUtils.IsDecimal(System.Char)">
            <summary>
            Checks whether the provided character is a decimal character (between 0 and 9).
            </summary>
            <param name="ch">The character to check.</param>
            <returns>Whether the provided character is a decimal character.</returns>
        </member>
        <member name="M:Loretta.Utilities.CharUtils.IsHexadecimal(System.Char)">
            <summary>
            Checks whether the provided character is a hexadecimal character.
            </summary>
            <param name="ch">The character to check.</param>
            <returns>Whether the provided character is hexadecimal.</returns>
        </member>
        <member name="M:Loretta.Utilities.CharUtils.IsAlpha(System.Char)">
            <summary>
            Checks whether the provided character is an alpha character (a-z, A-Z).
            </summary>
            <param name="ch">The character to check.</param>
            <returns>Whether the provided character is an alpha character.</returns>
        </member>
        <member name="M:Loretta.Utilities.CharUtils.IsAlphaNumeric(System.Char)">
            <summary>
            Checks whether the provided character is an alphanumeric character (a-z, A-Z, 0-9).
            </summary>
            <param name="ch">The character to check.</param>
            <returns>Whether the provided character is an alphanumeric character.</returns>
        </member>
        <member name="M:Loretta.Utilities.CharUtils.IsValidFirstIdentifierChar(System.Boolean,System.Char)">
            <summary>
            Checks whether the provided character is a valid first identifier character.
            </summary>
            <param name="useLuaJitIdentifierRules">
            Whether to use LuaJIT's identifier matching rule.
            </param>
            <param name="ch">The character to check.</param>
            <returns>Whether the provided character is a valid first identifier character.</returns>
        </member>
        <member name="M:Loretta.Utilities.CharUtils.IsValidTrailingIdentifierChar(System.Boolean,System.Char)">
            <summary>
            Checks whether the provided character is a valid trailing identifier character.
            </summary>
            <param name="useLuaJitIdentifierRules">
            Whether to use LuaJIT's identifier matching rule.
            </param>
            <param name="ch">The character to check.</param>
            <returns>Whether the provided character is a valid trailing identifier character.</returns>
        </member>
        <member name="M:Loretta.Utilities.CharUtils.EncodeCharToUtf8(System.Char)">
            <summary>
            Encodes the provided character into a hexadecimal escape sequence representing its UTF-8 bytes.
            </summary>
            <param name="ch">The character to encode.</param>
            <returns>The provided character encoded in UTF-8 hexadecimal escape sequences.</returns>
        </member>
        <member name="T:Loretta.Utilities.StringUtils">
            <summary>
            A class with utilities for strings.
            </summary>
        </member>
        <member name="M:Loretta.Utilities.StringUtils.IsIdentifier(System.Boolean,System.ReadOnlySpan{System.Char})">
            <summary>
            Returns whether the provided string is a valid identifier.
            </summary>
            <param name="useLuaJitIdentifierRules">Whether to use LuaJIT's identifier rules.</param>
            <param name="value">The string to check.</param>
            <returns>Whether the provided string is a valid identifier.</returns>
        </member>
    </members>
</doc>
